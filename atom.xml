<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.virualyz.com/"/>
  <updated>2019-05-08T06:05:55.508Z</updated>
  <id>blog.virualyz.com/</id>
  
  <author>
    <name>xcxd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置</title>
    <link href="blog.virualyz.com/2019/05/07/2019-05-07_18-57-09_%E5%9C%A8mac%E7%89%88idea%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%BF%AB%E6%8D%B7%E6%B3%A8%E9%87%8A%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>blog.virualyz.com/2019/05/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/</id>
    <published>2019-05-07T10:00:00.000Z</published>
    <updated>2019-05-08T06:05:55.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在idea中使用阿里巴巴代码规范插件及方法、类头部注释方法</p><a id="more"></a><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="阿里巴巴代码规范插件"><a href="#阿里巴巴代码规范插件" class="headerlink" title="阿里巴巴代码规范插件"></a>阿里巴巴代码规范插件</h2><p>1、按照图示进入<br> <img src="/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/Snipaste_2019-04-04_20-58-07.jpg" alt="图片"></p><p>2、在marketplace中搜索，如果未安装则显示install，点击install</p><p> <img src="/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/Snipaste_2019-05-08_10-20-46.jpg" alt="图片"></p><p>3、在tool中找到图示，点击打开实时监测即可<br> <img src="/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/Snipaste_2019-05-08_10-28-32.jpg" alt="图片"></p><p>4、如果代码中有不符合阿里代码规范的会有提示<br> <img src="/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/Snipaste_2019-05-08_10-34-50.jpg" alt="图片"></p><h2 id="快捷注释"><a href="#快捷注释" class="headerlink" title="快捷注释"></a>快捷注释</h2><p>查找资料有许多人在图示地址进行配置class注释信息，感觉另一种方式更适合我<br> <img src="/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/Snipaste_2019-05-08_10-37-43.jpg" alt="图片"></p><p>我采用的方式<br> 1.在图示中选择1创建模板组myeTemplate，选择2创建具体模板，这里以class为例<br> 创建完毕后指定快捷键-&gt;class（可自定义），模板的描述description-&gt;class注释<br> 填写注释代码，注意：只有填写$$中间内容包裹的变量可以在</p><pre><code>/** * @Author: $author$ * @Date: $date$ **/</code></pre><p> <img src="/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/Snipaste_2019-05-08_10-42-12.jpg" alt="图片"></p><p> 触发快捷键的按键可以修改-&gt;默认tab，这里改为了enter，同时修改模板使用返回，一般全选即可，这里错了限定java</p><p>  <img src="/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/Snipaste_2019-05-08_11-12-30.jpg" alt="图片"></p><p> 2.点击下图1中的按钮，进入弹出框，可以看到，在Template test中$$包含的变量在弹出框中出现</p><p> <img src="/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/Snipaste_2019-05-08_10-59-21.jpg" alt="图片"></p><p> 3.在 expression中选择已有的信息，也可以通过default value进行默认赋值，或者通过表达式</p><pre><code>groovyScript(&quot;def result=&apos;&apos;; def params=\&quot;${_1}\&quot;.replaceAll(&apos;[\\\\[|\\\\]|\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 1; i &lt; params.size() +1; i++) {result+=&apos;* @param &apos; + params[i - 1] + &apos; &apos; + ((i &lt; params.size()) ? &apos;\\n &apos; : &apos;&apos;)}; return result&quot;, methodParameters())</code></pre><p>   <img src="/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/Snipaste_2019-05-08_11-03-28.jpg" alt="图片"></p><p> 4.校验一下<br> 可以在提示的代码上通过 option+enter 自动补全，但是此种补全是idea自带的格式，也可以通过如下方式<br>   <img src="/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/Snipaste_2019-05-08_13-43-26.jpg" alt="图片"></p><p>   <img src="/07/2019-05-07_18-57-09_在mac版idea中使用阿里巴巴代码规范插件及快捷注释的配置/Snipaste_2019-05-08_11-06-10.jpg" alt="图片"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.jianshu.com/p/8e4423744231?utm_campaign" target="_blank" rel="noopener">https://www.jianshu.com/p/8e4423744231?utm_campaign</a><br><a href="https://blog.csdn.net/weixin_42679529/article/details/81059598" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42679529/article/details/81059598</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在idea中使用阿里巴巴代码规范插件及方法、类头部注释方法&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="blog.virualyz.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="blog.virualyz.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(八)代理模式</title>
    <link href="blog.virualyz.com/2019/04/27/2019-04-27_21-19-35_12%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E5%85%AB)%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/04/27/2019-04-27_21-19-35_12种设计模式(八)代理模式/</id>
    <published>2019-04-27T10:00:00.000Z</published>
    <updated>2019-04-27T14:28:11.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>代理模式(Proxy Pattern)</p><a id="more"></a><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象<br>不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之<br>间起到中介的作用</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>是程序设计中的一种设计模式。是一种结构模式。</p><p>代理模式分为静态代理、动态代理</p><p>静态代理是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p><p>动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象</p><p>一个是真正的你要访问的对象(目标类)，一个是代理对象,真正对象与代理<br>对象实现同一个接口,先访问代理类再访问真正要访问的对象</p><h1 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h1><p>1、抽象角色：通过接口或抽象类声明真实角色实现的业务方法</p><p>2、代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作</p><p>3、真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用</p><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><h1 id="基本的实现思路"><a href="#基本的实现思路" class="headerlink" title="基本的实现思路"></a>基本的实现思路</h1><h1 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h1><p>引用计数（英语：reference counting）指针对象</p><p>当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少存储器用量。典型作法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、职责清晰，真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。</p><p>2、代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。</p><p>3、高扩展性</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1、这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性</p><p>2、装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</p><p>3、装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><h1 id="与其他模式的区别"><a href="#与其他模式的区别" class="headerlink" title="与其他模式的区别"></a>与其他模式的区别</h1><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baike.baidu.com/item/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/10218946?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/10218946?fr=aladdin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;代理模式(Proxy Pattern)&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(七)装饰器模式</title>
    <link href="blog.virualyz.com/2019/04/20/2019-04-20_21-24-43_23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%83)%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/04/20/2019-04-20_21-24-43_23种设计模式(七)装饰器模式/</id>
    <published>2019-04-20T10:00:00.000Z</published>
    <updated>2019-04-27T13:35:40.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>装饰器模式(Decorator Pattern)</p><a id="more"></a><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，<br>动态地扩展一个对象的功能。它是通过创建一个包装对象，<br>也就是装饰来包裹真实的对象</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>装饰模式允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计<br>模式属于结构型模式，它是作为现有的类的一个包装</p><h1 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h1><p>1、抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。</p><p>2、具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。</p><p>3、装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。</p><p>4、具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。</p><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能，比生成子类更为灵活</p><h1 id="基本的实现思路"><a href="#基本的实现思路" class="headerlink" title="基本的实现思路"></a>基本的实现思路</h1><p>将具体功能职责划分，同时继承装饰者模式</p><h1 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h1><p>java IO 流是典型的装饰模式</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1.、Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。</p><p>2、 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1、这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性</p><p>2、装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</p><p>3、装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><ol><li><p>需要扩展一个类的功能，或给一个类添加附加职责</p></li><li><p>需要动态的给一个对象添加功能，这些功能可以再动态的撤销</p></li><li><p>需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。</p></li><li><p>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类</p></li></ol><h1 id="与其他模式的区别"><a href="#与其他模式的区别" class="headerlink" title="与其他模式的区别"></a>与其他模式的区别</h1><p>1、关于新职责：适配器也可以在转换时增加新的职责，但主要目的不在此。装饰者模式主要是给被装饰者增加新职责的。</p><p>2、关于原接口：适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。（增加新接口的装饰者模式可以认为是其变种–“半透明”装饰者）</p><p>3、关于其包裹的对象：适配器是知道被适配者的详细情况的（就是那个类或那个接口）。装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>接口</p><pre><code>/** * @author test * @date */public interface Home {    /**     * 家庭名称     * @return     */    void homeName();    /**     * 家庭地址     * @return     */    void homeAddress();}</code></pre><p>实现</p><pre><code>/** * @author test * @date */public class AmericanHome implements Home {    @Override    public void homeName(){        System.out.println(&quot;HomeName:AmericanH&quot;);    }    @Override    public void homeAddress(){        System.out.println(&quot;HomeAddress:AmericanH&quot;);    }}/** * @author test * @date */public class ChineseHome implements Home {    @Override    public void homeName(){        System.out.println(&quot;HomeName:Chinese&quot;);    }    @Override    public void homeAddress(){        System.out.println(&quot;HomeAddress:Chinese&quot;);    }}</code></pre><p>接口的抽象装饰类</p><pre><code>/** * @author test * @date */public abstract class HomeDecorator implements Home {    protected Home homeDecorator;    public HomeDecorator(Home homeDecorator){        this.homeDecorator = homeDecorator;    }    @Override    public void homeName(){        homeDecorator.homeName();    }    @Override    public void homeAddress(){        homeDecorator.homeAddress();    }}</code></pre><p>创建扩展了 抽象装饰类的实体装饰类</p><pre><code>/** * @author test * @date */public class NewHomeDecorator extends HomeDecorator {    public NewHomeDecorator(Home home){        super(home);    }    @Override    public void homeName(){        homeDecorator.homeName();        recordHomeComeFrom(homeDecorator);    }    @Override    public void homeAddress(){        homeDecorator.homeAddress();        recordHomeComeFrom(homeDecorator);    }    private void recordHomeComeFrom(Home home){        System.out.println(&quot;record come from: 已记录家庭来自的地址&quot;);    }}</code></pre><p>使用 实体装饰类 来装饰对象   </p><pre><code>/** * @author test * @date */public class Main {    public static void main(String[] args) {        Home home = new ChineseHome();        Home chineseHome = new NewHomeDecorator(new ChineseHome());        Home americanHome = new NewHomeDecorator(new AmericanHome());        System.out.println(&quot;Home with normal &quot;);        home.homeName();        home.homeAddress();        System.out.println(&quot;\nHome of chinese&quot;);        chineseHome.homeName();        chineseHome.homeAddress();        System.out.println(&quot;\nHome of american&quot;);        americanHome.homeName();        americanHome.homeAddress();    }}</code></pre><p>输出结果</p><pre><code>Home with normal HomeName:ChineseHomeAddress:ChineseHome of chineseHomeName:Chineserecord come from: 已记录家庭来自的地址HomeAddress:Chineserecord come from: 已记录家庭来自的地址Home of americanHomeName:Americanrecord come from: 已记录家庭来自的地址HomeAddress:Americanrecord come from: 已记录家庭来自的地址Process finished with exit code 0　</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baike.baidu.com/item/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/10218946?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/10218946?fr=aladdin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;装饰器模式(Decorator Pattern)&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(六)适配器模式</title>
    <link href="blog.virualyz.com/2019/04/17/2019-04-17_22-34-13_23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E5%85%AD)%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/04/17/2019-04-17_22-34-13_23种设计模式(六)适配器模式/</id>
    <published>2019-04-17T12:00:00.000Z</published>
    <updated>2019-04-19T14:43:23.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>适配器模式(Adapter Pattern)</p><a id="more"></a><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>又名为包装器(Wrapper)模式,将一个类的接口适配成用户所期待的。一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能</p><p>共有两类适配器模式：</p><h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><p>在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。</p><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>这种适配器模式下，适配器继承自已实现的类（一般多重继承）。</p><h1 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h1><p>1：Target(目标抽象类)：目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类。在类适配器中，由于C#语言不支持多重继承，所以它只能是接口。</p><p>2：Adapter(适配器类)：它可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。它是适配器模式的核心。</p><p>3：Adaptee(适配者类)：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类包好了客户希望的业务方法。</p><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>为了保留现有类所提供的服务，但是又需要新的服务去适应新的需求</p><h1 id="基本的实现思路"><a href="#基本的实现思路" class="headerlink" title="基本的实现思路"></a>基本的实现思路</h1><p>将类自己的接口包裹在一个已存在的类中。exp： a-&gt;a1,b  ==&gt; aa%% b==&gt; c</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1：将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。</p><p>2：增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一适配者类可以在多个不同的系统中复用。</p><p>3：灵活性和扩展性都非常好，通过使用配置文件，可以很方便的更换适配器，也可以在不修改原有代码的基础上 增加新的适配器，完全复合开闭原则</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1：一次最多只能适配一个适配者类，不能同时适配多个适配者。</p><p>2：适配者类不能为最终类</p><p>3：目标抽象类只能为接口，不能为类，其使用有一定的局限性</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>1、在已有的接口中不适用现有需求，需要扩展这些接口使用</p><p>2、创建一个可重复用的类，用于连接一些彼此没有关联的类，以及以后可能会在将来使用的类</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="类适配器模式："><a href="#类适配器模式：" class="headerlink" title="类适配器模式："></a>类适配器模式：</h2><p>　　原理：通过继承来实现适配器功能</p><p>有一台mac电脑，他的接口是typec类型的，现在有一台显示器是vga接口的，需要要一个转换器，<br>这个转换器让显示器vga也可以用typec</p><p>typec</p><pre><code>/** * Typec * * @author test * @date */public interface Typec {    /**     *     * @return     */    void isTypec();}</code></pre><p>vga</p><pre><code>/** * Vga * * @author test * @date */public interface Vga {    /**     *     * @return     */    void isVga();}</code></pre><p>typec实现类</p><pre><code>/** * UseTypec * * @author test * @date */public class UseTypec implements Typec {    @Override    public void isTypec() {        System.out.println(&quot;Typec&quot;);    }}</code></pre><p>适配器 Adapter</p><pre><code>/** * Adapter * * @author test * @date */public class Adapter extends UseTypec implements Vga {    @Override    public void isVga() {        isTypec();    }}</code></pre><p>测试</p><pre><code>/** * Main * * @author test * @date */public class Main {    public static void main(String[] args) {        UseTypec p = new Adapter();        p.isTypec();    }}</code></pre><p>输出结果</p><pre><code>Typec</code></pre><p>　  接口typec：描述typec接口格式</p><p>　　接口vga：描述vga接口格式</p><p>　　类UseTypec：是接口Typec的实现类，是具体的ypec接口格式</p><p>　　Adapter：用于将vga接口格式转换成为Typec接口格式T</p><h2 id="对象适配器模式-1"><a href="#对象适配器模式-1" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>原理：通过组合来实现适配器功能</p><p>相对于类适配器，对象适配器通过在适配器内定义私有变量，并通过带参数的构造方法为<br>此定义变量进行赋值，然后在实现a接口的方法中调用b中的方法</p><p>typec</p><pre><code>/** * Typec * * @author test * @date */public interface Typec {    /**     *     * @return     */    void isTypec();}</code></pre><p>vga</p><pre><code>/** * Vga * * @author test * @date */public interface Vga {    /**     *     * @return     */    void isVga();}</code></pre><p>typec实现类</p><pre><code>/** * UseTypec * * @author test * @date */public class UseTypec implements Typec {    @Override    public void isTypec() {        System.out.println(&quot;Typec&quot;);    }}</code></pre><p>适配器 Adapter</p><pre><code>/** * Adapter * * @author test * @date */public class Adapter implements Vga {    private Typec typec;    public Adapter(Typec typec){        this.typec = typec;    }    @Override    public void isVga() {        typec.isTypec();    }}</code></pre><p>测试</p><pre><code>public static void main(String[] args) {        Vga p = new Adapter(new UseTypec());        p.isVga();}</code></pre><p>输出结果</p><pre><code>Typec</code></pre><h3 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h3><p>原理：通过抽象类来实现适配</p><p>基于类适配器，当只需要接口typec中的部分方法，但是接口中有许多方法，我们实现接口<br>则需要实现其中的所有方法，这时我们可以通过抽象类来实现接口，并<br>不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想<br>用的方法的方式来实现。这个抽象类就是适配器。</p><p>接口typec</p><pre><code>/** * * @author test * @date */public interface Typec {    void charge();    void sound();    void connectingCellPhone();}</code></pre><p>适配器</p><pre><code>/** * * @author test * @date */public abstract class Adapter implements Typec {    @Override    public void charge(){}    @Override    public void sound(){}    @Override    public void connectingCellPhone(){}}</code></pre><p>使用类</p><pre><code>/** * * @author test * @date */public class UseTypec extends Adapter {    @Override    public void charge(){        System.out.println(&quot;实现充电方法被调用&quot;);    }    @Override    public void connectingCellPhone(){        System.out.println(&quot;实现连接手机方法被调用&quot;);    }}</code></pre><p>测试类</p><pre><code>/** * * @author test * @date */public class Main {    public static void main(String[] args) {        UseTypec a = new UseTypec();        a.charge();        a.connectingCellPhone();    }}  </code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>类适配器与对象适配器的使用场景一致，仅仅是实现手段稍有区别</p><p>1、想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。</p><p>2、我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。</p><p>　　以上两个场景其实就是从两个角度来描述一类问题，那就是要访问的方法不在合适的接口里，一个从接口出发（被访问），一个从访问出发（主动访问）。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baike.baidu.com/item/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/10218946?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/10218946?fr=aladdin</a><br><a href="https://www.cnblogs.com/V1haoge/p/6479118.html" target="_blank" rel="noopener">https://www.cnblogs.com/V1haoge/p/6479118.html</a><br><a href="https://www.cnblogs.com/songyaqi/p/4805820.html" target="_blank" rel="noopener">https://www.cnblogs.com/songyaqi/p/4805820.html</a><br><a href="http://www.runoob.com/design-pattern/adapter-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/adapter-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;适配器模式(Adapter Pattern)&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(五)原型模式</title>
    <link href="blog.virualyz.com/2019/04/14/2019-04-13_21-54-47_23%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%94)%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/04/14/2019-04-13_21-54-47_23中设计模式(五)原型模式/</id>
    <published>2019-04-14T08:00:00.000Z</published>
    <updated>2019-04-17T14:53:31.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>原型模式(Prototype Pattern)</p><a id="more"></a><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式是一种创建型设计模式，原型模式(Prototype)允许一个对象再创建另外一个可定制的对象，<br>根本无需知道任何如何创建的细节</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象</p><h1 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h1><p>在这样的设计模式中，有以下几个角色：</p><p>1、客户（Client）角色：客户端类向原型管理器提出创建对象的请求</p><p>2、抽象原型（Prototype）角色：这是一个抽象角色，通常由一个C#接口或抽象类实现。此角色给出所有的具体原型类所需的接口。在C#中，抽象原型角色通常实现了ICloneable接口。</p><p>3、具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。</p><p>4、原型管理器（Prototype Manager）角色：创建具体原型类的对象，并记录每一个被创建的对象。</p><h1 id="基本的实现思路"><a href="#基本的实现思路" class="headerlink" title="基本的实现思路"></a>基本的实现思路</h1><p>通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、当创建的对象实例较为复杂的时候，使用原型模式可以简化对象的创建过程！</p><p>2、扩展性好，由于写原型模式的时候使用了抽象原型类，在客户端进行编程的时候可以将具体的原型类通过配置进行读取。</p><p>3、可以使用深度克隆来保存对象的状态，使用原型模式进行复制。当你需要恢复到某一时刻就直接跳到。比如我们的idea种就有历史版本，或则SVN中也有这样的操作。非常好用！</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1、需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的里面，当对已有的类经行改造时需要修改源代码，违背了开闭原则。</p><p>2、在实现深克隆的时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用的时候，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现相对麻烦。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>1创建对象成本比较大，比如初始化要很长时间的，占用太多CPU的，新对象可以通过复制已有的对象获得的，如果是相似的对象，则可以对其成员变量稍作修改。</p><p>2系统要保存对象状态的，而对象的状态改变很小。</p><p>3需要避免使用分层次的工厂类来创建分层次的对象，并且类的对象就只用一个或很少的组合状态！</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>1、创建一个实现了 Cloneable 接口的抽象类。</p><pre><code>public abstract class Shape implements Cloneable {   private String id;   protected String type;   abstract void draw();   public String getType(){      return type;   }   public String getId() {      return id;   }   public void setId(String id) {      this.id = id;   }   public Object clone() {      Object clone = null;      try {         clone = super.clone();      } catch (CloneNotSupportedException e) {         e.printStackTrace();      }      return clone;   }}</code></pre><p>2、创建扩展了上面抽象类的实体类</p><pre><code>public class Rectangle extends Shape {   public Rectangle(){     type = &quot;Rectangle&quot;;   }   @Override   public void draw() {      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);   }}public class Square extends Shape {   public Square(){     type = &quot;Square&quot;;   }   @Override   public void draw() {      System.out.println(&quot;Inside Square::draw() method.&quot;);   }}public class Circle extends Shape {   public Circle(){     type = &quot;Circle&quot;;   }   @Override   public void draw() {      System.out.println(&quot;Inside Circle::draw() method.&quot;);   }}</code></pre><p>3、创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中</p><pre><code>import java.util.Hashtable;public class ShapeCache {   private static Hashtable&lt;String, Shape&gt; shapeMap       = new Hashtable&lt;String, Shape&gt;();   public static Shape getShape(String shapeId) {      Shape cachedShape = shapeMap.get(shapeId);      return (Shape) cachedShape.clone();   }   // 对每种形状都运行数据库查询，并创建该形状   // shapeMap.put(shapeKey, shape);   // 例如，我们要添加三种形状   public static void loadCache() {      Circle circle = new Circle();      circle.setId(&quot;1&quot;);      shapeMap.put(circle.getId(),circle);      Square square = new Square();      square.setId(&quot;2&quot;);      shapeMap.put(square.getId(),square);      Rectangle rectangle = new Rectangle();      rectangle.setId(&quot;3&quot;);      shapeMap.put(rectangle.getId(),rectangle);   }}</code></pre><p>4、PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆</p><pre><code>public class PrototypePatternDemo {   public static void main(String[] args) {      ShapeCache.loadCache();      Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;);      System.out.println(&quot;Shape : &quot; + clonedShape.getType());              Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;);      System.out.println(&quot;Shape : &quot; + clonedShape2.getType());              Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;);      System.out.println(&quot;Shape : &quot; + clonedShape3.getType());           }}</code></pre><p>5、客户端类代码片段：</p><p>   在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><pre><code>package com.test.builder;public class TestMain {    //something    Builder builder = new ConcreteBuilder();    Director director = new Director(builder);    Product product = director.construct();    //something}</code></pre><p>输出结果：</p><pre><code>Shape : CircleShape : SquareShape : Rectangle</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/4941014?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/4941014?fr=aladdin</a><br><a href="https://blog.csdn.net/qq_40709468/article/details/82316418" target="_blank" rel="noopener">https://blog.csdn.net/qq_40709468/article/details/82316418</a><br><a href="http://www.runoob.com/design-pattern/prototype-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/prototype-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;原型模式(Prototype Pattern)&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(四)建造者(生成器)模式</title>
    <link href="blog.virualyz.com/2019/04/07/2019-04-07_19-08-37_23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E5%9B%9B)%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/04/07/2019-04-07_19-08-37_23种设计模式(四)建造者模式/</id>
    <published>2019-04-07T10:00:00.000Z</published>
    <updated>2019-04-14T13:53:19.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>学习建造者(生成器)模式(builder Pattern)</p><a id="more"></a><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式，又名生成器模式，是一种软件设计模式，<br>属于创建型模式。建造者模式将一个复杂对象的构建与它的表示分离，<br>使得同样的构建过程可以创建不同的表示(属性)。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节</p><h1 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h1><p>在这样的设计模式中，有以下几个角色：</p><p>1、builder（抽象建造者）：为创建一个产品对象的各个部件指定抽象接口。</p><p>2、ConcreteBuilder（具体建造者）：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。</p><p>3、Director（指挥者）：构造一个使用Builder接口的对象。 它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程</p><p>4、Product（产品角色）：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</p><h1 id="基本的实现思路"><a href="#基本的实现思路" class="headerlink" title="基本的实现思路"></a>基本的实现思路</h1><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、不必知道产品内部组成的细节，产品的建造和表示分离，实现了解耦。</p><p>2、隐藏了产品的建造细节，用户只需关心产品的表示，而不需要了解是如何创建产品的。</p><p>3、每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 </p><p>4、可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</p><p>5、体现了开闭原则，增加新的具体建造者无须修改原有建造者代码，指挥者类针对抽象建造者类编程，扩展方便</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1、当建造者过多时，会产生很多类，难以维护。</p><p>2、产品之间差异性很大的情况：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制</p><p>3、产品内部变化很复杂的情况：产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>1、当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 [1] </p><p>2、当构造过程必须允许被构造的对象有不同表示时。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>1、一个典型的复杂对象其类代码示例如下：</p><pre><code>package com.test.builder;public class Product {    /**     * 可以是任意类型     */    private String partA;    private String partB;    private String partC;    public String getPartA() {        return partA;    }    public void setPartA(String partA) {        this.partA = partA;    }    public String getPartB() {        return partB;    }    public void setPartB(String partB) {        this.partB = partB;    }    public String getPartC() {        return partC;    }    public void setPartC(String partC) {        this.partC = partC;    }}</code></pre><p>2、抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：</p><pre><code>public abstract class Builder{    protected Product product=new Product();    public abstract void buildPartA();    public abstract void buildPartB();    public abstract void buildPartC();    public Product getResult()    {        return product;    }}</code></pre><p>3、具体建造者。实现抽象接口，构建和装配各个部件,实例代码如下：</p><pre><code>package com.test.builder;public class ConcreteBuilder extends Builder{    @Override    public void buildPartA(){    //something    }    @Override    public void buildPartB(){    //something    }    @Override    public void buildPartC(){    //something    }}</code></pre><p>4、指挥者类的代码示例如下：<br>  建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p><pre><code>package com.test.builder;/** * Director * * @author xxx */public class Director {    private Builder builder;    /**     * 1构造方法的方式注入builder对象     * @param builder     */    public Director(Builder builder)    {        this.builder = builder;    }    /**     * 2 set方法注入builder对象     * @param builder     */    public void setBuilder(Builder builder)    {        this.builder = builder;    }    public Product construct()    {        builder.buildPartA();        builder.buildPartB();        builder.buildPartC();        return builder.getResult();    }}</code></pre><p>5、客户端类代码片段：</p><p>   在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><pre><code>package com.test.builder;public class TestMain {    //something    Builder builder = new ConcreteBuilder();    Director director = new Director(builder);    Product product = director.construct();    //something}</code></pre><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="贩卖不同内容的纸"><a href="#贩卖不同内容的纸" class="headerlink" title="贩卖不同内容的纸"></a>贩卖不同内容的纸</h2><p>建造者模式可以用于描述创建不同内容的纸张<br>一张纸上的内容一般包含很多内容，按照头部，身体 脚等区分内容<br>不同的纸有不同的组成内容，可以根据顾客的要求，<br>一步一步装配这些组成部分，构造一份客户需要的内容的纸给他。</p><h3 id="Product（产品角色）"><a href="#Product（产品角色）" class="headerlink" title="Product（产品角色）"></a>Product（产品角色）</h3><p>具体的产品对象</p><pre><code>package com.test.test;public class Paper {    private String head;    private String body;    private String hand;    private String foot;    public String getHead() {        return head;    }    public void setHead(String head) {        this.head = head;    }    public String getBody() {        return body;    }    public void setBody(String body) {        this.body = body;    }    public String getHand() {        return hand;    }    public void setHand(String hand) {        this.hand = hand;    }    public String getFoot() {        return foot;    }    public void setFoot(String foot) {        this.foot = foot;    }}</code></pre><h3 id="Builder（抽象建造者）"><a href="#Builder（抽象建造者）" class="headerlink" title="Builder（抽象建造者）"></a>Builder（抽象建造者）</h3><p>创建一个Product对象的各个部件指定的抽象接口。</p><pre><code>package com.test.test;public abstract class PaperBuilder {    Paper paper = new Paper();    public abstract void buildHead();    public abstract void buildBody();    public abstract void builHand();    public abstract void buildFoot();    public Paper getPaper(){        return paper;    }}</code></pre><h3 id="ConcreteBuilder（具体建造者）"><a href="#ConcreteBuilder（具体建造者）" class="headerlink" title="ConcreteBuilder（具体建造者）"></a>ConcreteBuilder（具体建造者）</h3><p>实现抽象接口，构建和装配各个部件</p><p>纸张A</p><pre><code>package com.test.test;public class PaperA extends PaperBuilder{    @Override    public void buildHead(){        paper.setHead(&quot;A&quot;);    }    @Override    public void buildBody(){        paper.setBody(&quot;类型1&quot;);    }    @Override    public void builHand(){        paper.setHand(&quot;无手&quot;);    }    @Override    public void buildFoot(){        paper.setFoot(&quot;42码的脚&quot;);    }}</code></pre><p>纸张B</p><pre><code>package com.test.test;public class PaperB extends PaperBuilder{    @Override    public void buildHead(){        paper.setHead(&quot;B&quot;);    }    @Override    public void buildBody(){        paper.setBody(&quot;类型2&quot;);    }    @Override    public void builHand(){        paper.setHand(&quot;有手&quot;);    }    @Override    public void buildFoot(){        paper.setFoot(&quot;24码的脚&quot;);    }}</code></pre><h3 id="Director（指挥者）"><a href="#Director（指挥者）" class="headerlink" title="Director（指挥者）"></a>Director（指挥者）</h3><p>构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象，它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程</p><pre><code>package com.test.test;public class PaperDirector {    private PaperBuilder PaperBuilder;    public PaperDirector(PaperBuilder PaperBuilder) {        this.PaperBuilder = PaperBuilder;    }    public Paper construct(){        //        PaperBuilder.buildHead();        //        PaperBuilder.buildBody();        //        PaperBuilder.builHand();        //        PaperBuilder.buildFoot();        //准备完毕，返回一个完整的纸给客户        return PaperBuilder.getPaper();    }}</code></pre><h3 id="测试类-客户端类"><a href="#测试类-客户端类" class="headerlink" title="测试类(客户端类)"></a>测试类(客户端类)</h3><pre><code>package com.test.test;public class Test {    public static void main(String[] args) {        //纸A        PaperA a = new PaperA();        //准备纸A的管理者        PaperDirector waiter = new PaperDirector(a);        //获得套餐        Paper PaperA = waiter.construct();        System.out.print(&quot;纸A的组成部分:&quot;);        System.out.println(&quot;头：&quot;+PaperA.getHead()+&quot;；   &quot;+&quot;身体：&quot;+PaperA.getBody()+&quot;；   &quot; + &quot;手：&quot; + PaperA.getHand()+&quot;；   &quot; + &quot;脚：&quot; + PaperA.getFoot());    }}</code></pre><p>输出结果：</p><pre><code>纸A的组成部分:头：A；   身体：类型1；   手：无手；   脚：42码的脚</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>建造者模式的使用场合是当创建复杂对象时，把创建对象成员和装配方法分离出来，放在建造者类中去实现，用户使用该复杂对象时，不用理会它的创建和装配过程，只关心它的表示形式</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baike.baidu.com/item/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/3229729" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/3229729</a><br><a href="https://www.cnblogs.com/jenkinschan/p/6426694.html" target="_blank" rel="noopener">https://www.cnblogs.com/jenkinschan/p/6426694.html</a><br><a href="https://blog.csdn.net/u010102390/article/details/80179754" target="_blank" rel="noopener">https://blog.csdn.net/u010102390/article/details/80179754</a><br><a href="https://www.cnblogs.com/snailclimb/p/builderpattern.html" target="_blank" rel="noopener">https://www.cnblogs.com/snailclimb/p/builderpattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;学习建造者(生成器)模式(builder Pattern)&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(三)单例模式</title>
    <link href="blog.virualyz.com/2019/04/06/2019-04-06_20-40-38_23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%89)%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/04/06/2019-04-06_20-40-38_23种设计模式(三)单例模式/</id>
    <published>2019-04-06T12:00:00.000Z</published>
    <updated>2019-04-14T13:52:38.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>学习单例模式(Singleton pattern)<br><a id="more"></a></p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式，是一种常用的软件设计模式，是最简单的设计模式之一，<br>属于创建型模式，它提供了一种创建对象的最佳方式。在它的核心结构中只包含一个被称为<br>单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个<br>实例。即一个类只有一个对象实例。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，<br>可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一<br>实例的机制，“阻止”所有想要生成对象的访问。使用工厂方法来限制实例化过<br>程。这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一<br>实例毫无意义。</p><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>对于系统中的某些类来说，只有一个实例很重要。如：一个系统只能有一个任务管理器，<br>如果有多个一样的任务管理会造成资源浪费，如果有多个不一样的任务管理器，会造成<br>分辨困难，乃至无法分辨。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？<br>定义一个全局变量可以确保对象随时都可以被访问，<br>但不能防止我们实例化多个对象。<br>一个更好的解决办法是让类自身负责保存它的唯一实例。<br>这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。<br>这就是单例模式的模式动机。</p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>1、单例类只能有一个实例</p><p>2、单例类必须自己创建自己的唯一实例</p><p>3、单例类必须自行给所有其他对象提供这一唯一实例</p><h1 id="基本的实现思路"><a href="#基本的实现思路" class="headerlink" title="基本的实现思路"></a>基本的实现思路</h1><p>单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。</p><p>单例的实现主要是通过以下两个步骤：</p><p>1、将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</p><p>2、在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：</p><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例</p><p>2、避免对资源的多重占用（比如写文件操作）</p><p>缺点：</p><p>1、没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p>2、当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，<br>可能会给其他开发人员造成困扰，特别是看不到源码的时候。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>1、需要频繁的进行创建和销毁的对象</p><p>2、创建对象时耗时过多或耗费资源过多，但又经常用到的对象</p><p>3、工具类对象</p><p>4、频繁访问数据库或文件的对象</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>单例模式在多线程的应用场合下必须小心使用。<br>如果当唯一实例尚未创建时，有两个线程同时调用创建方法，<br>那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，<br>这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。<br>解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁<br>(虽然这样会降低效率)。</p><h1 id="单例的各种类型介绍"><a href="#单例的各种类型介绍" class="headerlink" title="单例的各种类型介绍"></a>单例的各种类型介绍</h1><p>通常单例模式在Java语言中，有两种构建方式：</p><p>  饿汉方式：指全局的单例实例在类装载时构建</p><p>  懒汉方式：指全局的单例实例在第一次被使用时构建</p><h2 id="饿汉方式"><a href="#饿汉方式" class="headerlink" title="饿汉方式"></a>饿汉方式</h2><h3 id="饿汉方式：静态常量-推荐"><a href="#饿汉方式：静态常量-推荐" class="headerlink" title="饿汉方式：静态常量-推荐"></a>饿汉方式：静态常量-推荐</h3><p>   类型特点：静态常量</p><p>   问题：无</p><p>   是否建议使用：推荐</p><pre><code>public class Singleton {    private final static Singleton INSTANCE = new Singleton();    //私有构造    private Singleton(){}    public static Singleton getInstance(){        return INSTANCE;    }}</code></pre><p>   优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p><p>   缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p><h3 id="饿汉方式：静态代码块-推荐"><a href="#饿汉方式：静态代码块-推荐" class="headerlink" title="饿汉方式：静态代码块-推荐"></a>饿汉方式：静态代码块-推荐</h3><p>   类型特点：静态代码块</p><p>   问题：无</p><p>   是否建议使用：推荐</p><pre><code>public class Singleton {    private static Singleton instance;    static {        instance = new Singleton();    }    private Singleton() {}    public static Singleton getInstance() {        return instance;    }}</code></pre><p>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h3 id="懒汉式：线程不安全-不推荐"><a href="#懒汉式：线程不安全-不推荐" class="headerlink" title="懒汉式：线程不安全-不推荐"></a>懒汉式：线程不安全-不推荐</h3><p>   类型特点：静态代码块</p><p>   类型问题：线程不安全</p><p>   是否建议使用：不推荐</p><pre><code>public class Singleton {    private static Singleton singleton;    private Singleton() {}    public static Singleton getInstance() {        if (singleton == null) {            singleton = new Singleton();        }        return singleton;    }}</code></pre><p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p><h3 id="懒汉式：同步方法-线程安全"><a href="#懒汉式：同步方法-线程安全" class="headerlink" title="懒汉式：同步方法-线程安全"></a>懒汉式：同步方法-线程安全</h3><p>   类型特点：同步方法</p><p>   问题：无（线程安全）</p><p>   是否建议使用：不推荐</p><pre><code>public class Singleton {    private static Singleton singleton;    private Singleton() {}    public static synchronized Singleton getInstance() {        if (singleton == null) {            singleton = new Singleton();        }        return singleton;    }}</code></pre><p>解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。</p><p>缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</p><h3 id="懒汉式：同步代码块-线程安全-不推荐"><a href="#懒汉式：同步代码块-线程安全-不推荐" class="headerlink" title="懒汉式：同步代码块-线程安全-不推荐"></a>懒汉式：同步代码块-线程安全-不推荐</h3><p>   类型特点：同步代码块</p><p>   问题：无（线程安全）</p><p>   是否建议使用：不推荐</p><pre><code>public class Singleton {    private static Singleton singleton;    private Singleton() {}    public static Singleton getInstance() {        if (singleton == null) {            synchronized (Singleton.class) {                singleton = new Singleton();            }        }        return singleton;    }}</code></pre><p>由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</p><h2 id="拓展类型"><a href="#拓展类型" class="headerlink" title="拓展类型"></a>拓展类型</h2><h3 id="双重检查：同步代码块-线程安全-推荐"><a href="#双重检查：同步代码块-线程安全-推荐" class="headerlink" title="双重检查：同步代码块-线程安全-推荐"></a>双重检查：同步代码块-线程安全-推荐</h3><p>   类型特点：同步代码块</p><p>   问题：无（线程安全）</p><p>   是否建议使用：推荐</p><pre><code>public class Singleton {    private static volatile Singleton singleton;    private Singleton() {}    public static Singleton getInstance() {        if (singleton == null) {            synchronized (Singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }}    </code></pre><p>如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。</p><p>优点；延迟加载；效率较高</p><h3 id="静态内部类：推荐"><a href="#静态内部类：推荐" class="headerlink" title="静态内部类：推荐"></a>静态内部类：推荐</h3><p>   类型特点：静态内部类</p><p>   问题：无（线程安全）</p><p>   是否建议使用：推荐</p><pre><code>public class Singleton {    private static volatile Singleton singleton;    private Singleton() {}    public static Singleton getInstance() {        if (singleton == null) {            synchronized (Singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }}  </code></pre><p>种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</p><p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p><p>优点：延迟加载，效率较高。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code>public enum Singleton {    INSTANCE;    public void whateverMethod() {    }}</code></pre><p>枚举方法的调用方式</p><pre><code>Singleton.INSTANCE.whateverMethod();</code></pre><p>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，不知道是不是1.5加入，所以使用较少</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/singleton-pattern.html</a><br><a href="https://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaoyan001/p/6365064.html</a><br><a href="https://baike.baidu.com/item/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/5946627?fr=aladdin#reference-[2]-1859857-wrap" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/5946627?fr=aladdin#reference-[2]-1859857-wrap</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;学习单例模式(Singleton pattern)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mysql中like何时使用索引</title>
    <link href="blog.virualyz.com/2019/04/04/2019-04-02_22-24-09_mysql%E4%B8%ADlike%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/"/>
    <id>blog.virualyz.com/2019/04/04/2019-04-02_22-24-09_mysql中like何时使用索引/</id>
    <published>2019-04-04T14:00:00.000Z</published>
    <updated>2019-04-04T13:36:36.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>生产环境有个sql查询，我自己查询挺慢的，但是我又看了下表，查询的字段是有索引的，所以我在奇怪，拿出log的日志</p><pre><code>select * from table where a like &apos;%xxx%&apos;</code></pre><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要解决在sql中使用like,不触发索引,探讨怎么使like下使用索引</p><a id="more"></a><h2 id="探讨过程"><a href="#探讨过程" class="headerlink" title="探讨过程"></a>探讨过程</h2><p>当sql中使用like关键字进行查询数据，这个时候所进行like的字段在部分情况下是无法使用到数据的索引的</p><pre><code>select * from table where a like &apos;%xxx%&apos;</code></pre><p><img src="/04/2019-04-02_22-24-09_mysql中like何时使用索引/Snipaste_2019-04-04_20-58-07.jpg" alt="图片"></p><p>这时索引a是存在的，但是在explain后type为all，至此a索引完全没用上</p><p>那既然like ‘%xxx%’不行，我们试一下’%xxx’</p><pre><code>select * from table where a like &apos;xxx%&apos;</code></pre><p><img src="/04/2019-04-02_22-24-09_mysql中like何时使用索引/Snipaste_2019-04-04_21-10-16.jpg" alt="图片"></p><p>这时还是没有使用到了索引a，那我们再换一下，试一下’xxx%’</p><p><img src="/04/2019-04-02_22-24-09_mysql中like何时使用索引/Snipaste_2019-04-04_21-08-10.jpg" alt="图片"></p><p>这时使用到了a的索引</p><p>所以当使用like时，如果想要使用索引通过 like ‘xxx%’，可以使用该字段的索引</p><p>如上所述，如果想要使用索引所使用的方式无法完成我们想要完成的。此时可以通过</p><p>LOCATE（’substr’,str,pos），FIND_IN_SET(str1,str2)</p><p>##总结<br>like 需要使用索引必须是 ‘xxx%’,LOCATE,FIND_IN_SET均可完成like模糊查询，<br>速度上这2个比用 like 稍快了一点。(不过这2个函数都不能使用索引)</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/sinat_41780498/article/details/83024781" target="_blank" rel="noopener">https://blog.csdn.net/sinat_41780498/article/details/83024781</a><br><a href="http://www.cnblogs.com/tommy-huang/p/4483583.html" target="_blank" rel="noopener">http://www.cnblogs.com/tommy-huang/p/4483583.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;生产环境有个sql查询，我自己查询挺慢的，但是我又看了下表，查询的字段是有索引的，所以我在奇怪，拿出log的日志&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from table where a like &amp;apos;%xxx%&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要解决在sql中使用like,不触发索引,探讨怎么使like下使用索引&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="blog.virualyz.com/categories/mysql/"/>
    
    
      <category term="数据库" scheme="blog.virualyz.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(二)抽象工厂模式</title>
    <link href="blog.virualyz.com/2019/03/31/2019-03-31_16-43-12_23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/03/31/2019-03-31_16-43-12_23种设计模式(二)抽象工厂模式/</id>
    <published>2019-03-31T10:00:00.000Z</published>
    <updated>2019-03-31T13:57:09.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>学习抽象工厂模式(Abstract Factory)<br><a id="more"></a></p><h1 id="抽象工厂模式介绍"><a href="#抽象工厂模式介绍" class="headerlink" title="抽象工厂模式介绍"></a>抽象工厂模式介绍</h1><p>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。<br>抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。<br>抽象工厂模式可以向客户端提供一个接口，<br>使客户端在不必指定产品的具体的情况下，<br>创建多个产品族中的产品对象。根据里氏替换原则，任何接受父类型的地方，<br>都应当能够接受子类型。因此，实际上系统所需要的，<br>仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。<br>换言之，也就是这些抽象产品的具体子类的实例。<br>工厂类负责创建抽象产品的具体子类的实例</p><p>当每个抽象产品都有多于一个的具体子类的时候，工厂角色怎么知道实例化哪一个子类呢？比如每个抽象产品 [1]  角色都有两个具体产品。抽象工厂模式提供两个具体工厂角色，分别对应于这两个具体产品角色，每一个具体工厂角色只负责某一个产品角色的实例化。每一个具体工厂类只负责创建抽象产品的某一个具体子类的实例。<br>每一个模式都是针对一定问题的解决方案，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式针对的是多个产品等级结构。</p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>1、抽象工厂</p><p>2、具体工厂</p><p>3、抽象产品</p><p>4、具体产品</p><p>5、产品使用者</p><p>说明：</p><p>具体工厂“继承”抽象工厂；</p><p>具体产品”继承“抽象产品；</p><p>每个具体工厂（如PC工厂）包含若干个子工厂方法（如cpu工厂方法、显卡工厂方法…），子工厂方法负责生产对应的具体子产品，所有具体子产品（cpu、内存、显卡…）组合成一个具体产品（如惠普XXX型号PC）；</p><p>产品使用者使用每个具体工厂生产的具体产品；</p><h1 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h1><p>具体的实例代码：</p><p>1.抽象产品:衣服、裤子</p><p>1、衣服<br>    package com.test.demo;</p><pre><code>/** * * @author test */public interface Clothes {    /**     * 获得名字     */    void printName();}</code></pre><p>2、裤子</p><pre><code>package com.test.demo;/** * * @author test */public interface Pants {    /**     * 获得名字     */void printName();}</code></pre><p>2.具体产品：花花公子衣服、花花公子裤子、七匹狼衣服、七匹狼裤子</p><p>  1、花花公子衣服</p><pre><code>package com.test.demo;/** * * @author test */public class PlayBoyClothes implements Clothes{    private String name;    public PlayBoyClothes(String name) {        this.name = name;        System.out.println(&quot;create a PlayBoyClothes.&quot;);    }    /**     * @return the name     */    public String getName() {        return name;    }    /**     * @param name the name to set     */    public void setName(String name) {        this.name = name;    }    @Override    public void printName() {        System.out.println(this.getClass().getName() + &quot;:&quot; + this.name);    }}</code></pre><p>  2、花花公子裤子</p><pre><code>package com.test.demo;/** * * @author test */public class PlayBoyPants implements Pants{    private String name;    public PlayBoyPants(String name) {        this.name = name;        System.out.println(&quot;create a PlayBoyPants.&quot;);    }    /**     * @return the name     */    public String getName() {        return name;    }    /**     * @param name the name to set     */    public void setName(String name) {        this.name = name;    }    @Override    public void printName() {        System.out.println(this.getClass().getName() + &quot;:&quot; + this.name);    }}</code></pre><p>   3、七匹狼衣服</p><pre><code>package com.test.demo;/** * * @author test */public class SeptwolvesClothes implements Clothes{    private String name;    public SeptwolvesClothes(String name) {        this.name = name;        System.out.println(&quot;create a SeptwolvesClothes.&quot;);    }    /**     * @return the name     */    public String getName() {        return name;    }    /**     * @param name the name to set     */    public void setName(String name) {        this.name = name;    }    @Override    public void printName() {        System.out.println(this.getClass().getName() + &quot;:&quot; + this.name);    }}</code></pre><p>   4、七匹狼裤子<br>    package com.test.demo;</p><pre><code>/** * * @author test */public class SeptwolvesPants implements Pants{    private String name;    public SeptwolvesPants(String name) {        this.name = name;        System.out.println(&quot;create a SeptwolvesPants.&quot;);    }    /**     * @return the name     */    public String getName() {        return name;    }    /**     * @param name the name to set     */    public void setName(String name) {        this.name = name;    }    @Override    public void printName() {        System.out.println(this.getClass().getName() + &quot;:&quot; + this.name);    }}</code></pre><p>3.抽象工厂</p><pre><code>package com.test.demo;/** * * @author test */public interface SuitFactory {    Clothes createClothes(String name);    Pants createPants(String name);}</code></pre><p>4.具体工厂子类</p><p>   1、花花公子工厂</p><pre><code>package com.test.demo;/** * * @author test */public class PlayBoyFactory implements SuitFactory {    @Override    public Clothes createClothes(String name) {        return new PlayBoyClothes(name);    }    @Override    public Pants createPants(String name) {        return new PlayBoyPants(name);    }}</code></pre><p>   2、七匹狼工厂</p><pre><code>package com.test.demo;/** * * @author test */public class SeptwolvesFactory implements SuitFactory {    @Override    public Clothes createClothes(String name) {        return new SeptwolvesClothes(name);    }    @Override    public Pants createPants(String name) {        return new SeptwolvesPants(name);    }}</code></pre><p>最后，使用简单的测试类，来验证下 不同的工厂能够产生不同的产品对象：测试类如下：</p><pre><code>package com.test.demo;/** * * @author test */public class Test {    public static void main(String[] args) {        SuitFactory PlayBoyFactory = new PlayBoyFactory();        SuitFactory SeptwolvesFactory = new SeptwolvesFactory();        Clothes playBoyClothes = PlayBoyFactory.createClothes(&quot;PlayBoy秋冬上装&quot;);        Pants playBoyPants = PlayBoyFactory.createPants(&quot;PlayBoy秋冬裤子&quot;);        Clothes septwolvesClothes = SeptwolvesFactory.createClothes(&quot;Septwolves秋冬上装&quot;);        Pants septwolvesCants = SeptwolvesFactory.createPants(&quot;Septwolves秋冬裤子&quot;);        playBoyClothes.printName();        playBoyPants.printName();        septwolvesClothes.printName();        septwolvesCants.printName();    }}</code></pre><p>打印结果如下：</p><p>create a PlayBoyClothes.<br>create a PlayBoyPants.<br>create a SeptwolvesClothes.<br>create a SeptwolvesPants.<br>com.test.demo.PlayBoyClothes:PlayBoy秋冬上装<br>com.test.demo.PlayBoyPants:PlayBoy秋冬裤子<br>com.test.demo.SeptwolvesClothes:Septwolves秋冬上装<br>com.test.demo.SeptwolvesPants:Septwolves秋冬裤子</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/2361182" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/2361182</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;学习抽象工厂模式(Abstract Factory)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式延伸" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BB%B6%E4%BC%B8/"/>
    
    
      <category term="设计模式延伸" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BB%B6%E4%BC%B8/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式延伸-简单工厂模式</title>
    <link href="blog.virualyz.com/2019/03/31/2019-03-31_17-09-37_23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BB%B6%E4%BC%B8-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/03/31/2019-03-31_17-09-37_23种设计模式延伸-简单工厂模式/</id>
    <published>2019-03-31T08:00:00.000Z</published>
    <updated>2019-03-31T12:31:57.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>学习简单工厂模式<br><a id="more"></a></p><h1 id="简单工厂模式介绍"><a href="#简单工厂模式介绍" class="headerlink" title="简单工厂模式介绍"></a>简单工厂模式介绍</h1><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，<br>但不属于23种GOF设计模式之一。<br>简单工厂模式是工厂模式家族中最简单实用的模式，<br>可以理解为是不同工厂模式的一个特殊实现。</p><p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。<br>该模式中包含的角色及其职责</p><p>工厂（Creator）角色</p><pre><code>简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</code></pre><p>抽象产品（Product）角色</p><pre><code>简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</code></pre><p>具体产品（Concrete Product）角色</p><pre><code>是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。</code></pre><h1 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h1><p>案例的实例代码：</p><p>1.抽象的产品<br>    定义shoe</p><pre><code>package com.test.factory;/** * 产品的抽象接口  鞋子 * @author test * */public interface Shoe {    /**     * 获得名字     */    void getName();}</code></pre><p>2.实际的产品<br>    总共定义两个，ManShoe 和 WomanShoe 分别表示不同的鞋子</p><pre><code>package com.test;import com.test.factory.Shoe;/** * 具体产品类 * ManShoe  男鞋 * @author  test * */public class ManShoe implements Shoe {    @Override    public void getName() {        System.out.println(&quot;男鞋&quot;);    }}package com.test;import com.test.factory.Shoe;/** * 具体产品类 * WomanShoe 女鞋 * @author test * */public class WomanShoe implements Shoe {    @Override    public void getName() {        System.out.println(&quot;女鞋&quot;);    }}</code></pre><p>3.工厂<br>    简单工厂核心类：</p><pre><code>package com.test;import com.test.factory.Shoe;/** * 简单工厂核心类 * @author test * */public class SampleFactory {    public static Shoe makeShoe(String type){        if(&quot;ManShoe&quot;.equals(type)){            Shoe manShoe = new ManShoe();            return manShoe;        }else if(&quot;WomanWShoe&quot;.equals(type)){            Shoe womanShoe = new WomanShoe();            return womanShoe;        }else{            System.out.println(&quot;暂时没有此类鞋&quot;);            return null;        }    }}</code></pre><p>最后，使用简单的测试类，来验证下 工厂能够产生不同的产品对象：测试类如下：</p><pre><code>package com.test;import com.test.factory.Shoe;/** * 简单工厂测试 * @author test * */public class Client {    public static void main(String[] args) {        Shoe manShoe = SampleFactory.makeShoe(&quot;ManShoe&quot;);        System.out.println(null == manShoe);        if(null != manShoe){            manShoe.getName();        }        Shoe wommanShoe = SampleFactory.makeShoe(&quot;WomanShoe&quot;);        System.out.println(null == wommanShoe);        if(null != wommanShoe){            wommanShoe.getName();        }        Shoe neuterShoe = SampleFactory.makeShoe(&quot;NeuterShoe&quot;);        System.out.println(null == neuterShoe);        if(null != neuterShoe){            wommanShoe.getName();        }    }}</code></pre><p>打印结果如下：</p><p>false<br>男鞋<br>false<br>女鞋<br>没有此类鞋<br>true</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。<br>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；<br>这些缺点在工厂方法模式中得到了一定的克服。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>工厂类负责创建的对象比较少；<br>客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；<br>由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/8801727" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/8801727</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;学习简单工厂模式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式延伸" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BB%B6%E4%BC%B8/"/>
    
    
      <category term="设计模式延伸" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BB%B6%E4%BC%B8/"/>
    
  </entry>
  
  <entry>
    <title>mysql中or条件的使用优化避免全表扫描</title>
    <link href="blog.virualyz.com/2019/03/28/2019-03-28_22-39-35-mysql%E4%B8%ADor%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96%E9%81%BF%E5%85%8D%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F/"/>
    <id>blog.virualyz.com/2019/03/28/2019-03-28_22-39-35-mysql中or条件的使用优化避免全表扫描/</id>
    <published>2019-03-28T14:00:00.000Z</published>
    <updated>2019-03-28T15:01:03.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>生产环境有个sql很缓慢,查询了全表,类似</p><pre><code>select * from table where  = 1 or b = 2</code></pre><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要解决在sql中使用or的情况下,尽量避免sql进行全表查询，也就是type 显示all的情况</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p> MySQL在 5.0版本中引入新特性：索引合并优化(Index merge optimization)，当查询中单张表可以使用多个索引时，同时扫描多个索引并将扫描结果进行合并</p><p>该特新主要应用于以下三种场景：</p><p>1、对OR语句求并集，如查询SELECT * FROM TB1 WHERE c1=”xxx” OR c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果合并（union）操作，得到最终结果</p><p>2、对AND语句求交集，如查询SELECT * FROM TB1 WHERE c1=”xxx” AND c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果取交集（intersect）操作，得到最终结果</p><p>3、对AND和OR组合语句求结果</p><p>该新特性可以在一些场景中大幅度提升查询性能，但受限于MySQL糟糕的统计信息，也导致很多场景查询性能极差甚至导致数据库崩溃。</p><p>以SELECT * FROM table WHERE a=”xxx” AND a=””xxx” 为例：</p><p>1、当a列和b列选择性较高时，按照a和b条件进行查询性能较高且返回数据集较小，再对两个数据量较小的数据集求交集的操作成本也较低，最终整个语句查询高效；</p><p>2、当a列或b列选择性较差且统计信息不准时，比如整表数据量2000万，按照b列条件返回1500万数据，按照a列返回1000条数据，此时按照b列条件进行索引扫描+聚集索引查找的操作成本极高(可能是整表扫描的百倍消耗)，对1000条数据和1500万数据求交集的成本也极高，最终导致整条SQL需要消耗大量CPU和IO资源且相应时间超长，而如果值使用a列的索引，查询消耗资源较少且性能较高。</p><p>由于上述的问题，绝大多数的运维团队都会选择关闭该特性来避免执行异常，京东商城也出现过类似案例，严重影响业务正常运行。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在某些情况下，or条件可以避免全表扫描的。<br>1、where 语句里面如果带有or条件, myisam表能用到索引， innodb不行。</p><pre><code>mysql版本5.5.24测试不成功 mysql版本5.5.35innodb测试不成功</code></pre><p>2 .必须所有的or条件都必须是独立索引，独立索引通俗的讲就是自己这一列单独有一个索引</p><ol start="3"><li>用UNION替换OR (适用于索引列)</li></ol><pre><code>通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果. 对索引列使用OR将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低. </code></pre><ol start="4"><li>用in来替换or  </li></ol><pre><code>低效: select…. from location where loc_id = 10 or loc_id = 20 or loc_id = 30 高效 select… from location where loc_in  in (10,20,30);</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/hguisu/article/details/7106159" target="_blank" rel="noopener">https://blog.csdn.net/hguisu/article/details/7106159</a><br><a href="https://blog.csdn.net/fsp88927/article/details/80662422" target="_blank" rel="noopener">https://blog.csdn.net/fsp88927/article/details/80662422</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;生产环境有个sql很缓慢,查询了全表,类似&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from table where  = 1 or b = 2
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要解决在sql中使用or的情况下,尽量避免sql进行全表查询，也就是type 显示all的情况&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="blog.virualyz.com/categories/mysql/"/>
    
    
      <category term="数据库" scheme="blog.virualyz.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>mysql优化神器explain介绍</title>
    <link href="blog.virualyz.com/2019/03/16/2019-03-17_18-06-48_mysql%E4%BC%98%E5%8C%96%E7%A5%9E%E5%99%A8explain/"/>
    <id>blog.virualyz.com/2019/03/16/2019-03-17_18-06-48_mysql优化神器explain/</id>
    <published>2019-03-15T16:00:00.000Z</published>
    <updated>2019-03-18T05:42:28.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>explain是mysql提供的一个优化sql的命令,在5.6以及以后的版本中,<br>除select,如insert,update和delete均可以使用explain查看执行计划，<br>从而知道mysql是如何处理sql语句，分析查询语句或者表结构的性能瓶颈,<br>本次使用的mysql 版本为</p><pre><code>@@version5.6.38</code></pre><p>但是为与5.6之后版本关联起来，所以部分内容可能还会含有其他版本的内容</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>在sql语句前面增加 explain 即可,5.6.x版本显示部分字段需要添加部分关键字</p><pre><code>explain SELECT * FROM TABLE_NAMEexplain extended SELECT * FROM TABLE_NAME</code></pre><a id="more"></a> <h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>1.需要分析的sql</p><p>2.数据库工具或直接连接数据库</p><p>这里我们创建表来查看</p><pre><code>CREATE TABLE `test_table_3` (  `id`   BIGINT(63)  NOT NULL AUTO_INCREMENT,  `ball_name` VARCHAR(125) NOT NULL DEFAULT &apos;&apos;,  `size`  INT(115)              DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `ball_name_index` (`ball_name`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;1&apos;, 100);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;2&apos;, 200);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;3&apos;, 300);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;4&apos;, 400);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;5&apos;, 500);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;6&apos;, 600);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;7&apos;, 700);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;8&apos;, 800);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;9&apos;, 900);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;10&apos;, 1000);CREATE TABLE `test_table_4` (  `id`           BIGINT(15)  NOT NULL AUTO_INCREMENT,  `ball_id`      BIGINT(15)           DEFAULT NULL,  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,  `productor`    VARCHAR(30)          DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `user_product_detail_index` (`ball_id`, `product_name`, `productor`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (1, &apos;A&apos;, &apos;耐克&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (1, &apos;B&apos;, &apos;李宁&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (1, &apos;A&apos;, &apos;安踏&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (2, &apos;A&apos;, &apos;耐克&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (2, &apos;C&apos;, &apos;李宁&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (3, &apos;D&apos;, &apos;361&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (4, &apos;A&apos;, &apos;耐克&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (6, &apos;A&apos;, &apos;耐克&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (9, &apos;E&apos;, &apos;特步&apos;);</code></pre><h1 id="介绍explain查询出的每项的含义"><a href="#介绍explain查询出的每项的含义" class="headerlink" title="介绍explain查询出的每项的含义"></a>介绍explain查询出的每项的含义</h1><p>   执行sql </p><pre><code>explain select * from test_table_3 where id = 2</code></pre><p>   <img src="/16/2019-03-17_18-06-48_mysql优化神器explain/Snipaste_2019-03-17_17-25-55.jpg" alt="图片"></p><h2 id="列介绍"><a href="#列介绍" class="headerlink" title="列介绍"></a>列介绍</h2><p>各列的含义如下:</p><pre><code>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.select_type: SELECT 查询的类型.table: 查询的是哪个表partitions: 匹配的分区type: join 类型possible_keys: 此次查询中可能选用的索引key: 此次查询中确切使用到的索引.ref: 哪个字段或常数与 key 一起被使用rows: 显示此查询一共扫描了多少行. 这个是一个估计值.filtered: 表示此查询条件所过滤的数据的百分比extra: 额外的信息</code></pre><h2 id="每列数值分析"><a href="#每列数值分析" class="headerlink" title="每列数值分析"></a>每列数值分析</h2><p>   id:由数据库分配的id,无特定的某些数值</p><pre><code>1. ID如果相同，可以认为是一组，从上往下顺序执行2. ID不同,其中ID越大，优先级越高，越早执行3. ID列为null的就表是这是一个结果集，不需要使用它来进行查询。</code></pre><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p> 表示了查询的类型,主要用于区别普通查询，联合查询，子查询等的复杂查询。<br>它的值有:</p><pre><code>SIMPLE, 表示此查询不包含 UNION 查询或子查询PRIMARY, 表示此查询是最外层的查询UNION, 表示此查询是 UNION 的第二或随后的查询DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询UNION RESULT, UNION 的结果SUBQUERY, 子查询中的第一个 SELECTDEPENDENT SUBQUERY(会严重消耗性能): 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.DERIVED：被驱动的SELECT子查询（子查询位于FROM子句）MATERIALIZED：被物化的子查询UNCACHEABLE SUBQUERY：对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作）UNCACHEABLE UNION：UNION操作中，内层的不可被物化的子查询（类似于UNCACHEABLE SUBQUERY）</code></pre><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>本次sql使用的表</p><pre><code>1.如果查询使用了别名,那么这里显示的是别名2.如果不涉及对数据表的操作，那么这显示为null。3.如果显示为尖括号括起来的&lt;derived N&gt;就表示这个是临时表，后边的N就是执行计划中的id,表示结果来自于这个查询产生。4.如果是尖括号括起来的&lt;union M,N&gt;，与&lt;derived N&gt;类似,也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。</code></pre><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>提供了判断查询是否高效的重要依据. 通过此字段, 我们判断此次查询是 全表扫描 还是 索引扫描</p><p>通常来说, 不同的 type 类型的性能关系如下:</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; unique_subquery &gt; index_subquery &gt; range &gt; index_merge &gt; index &gt; ALL</p><p>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><p>除了all之外，其他的type都可以使用到索引，<br>除了index_merge之外，其他的type只可以用到一个索引</p><p>常用的值有:</p><pre><code>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。因为仅有一行，在这行的列值可被优化器认为是常数.onst表很快，因为它们只读取一次！其他数据库也叫做唯一索引扫描        system: 表中只有一条数据. 这个类型是特殊的 const 类型.        表中只有一行数据或者是空表，且只能用于myisam和memory表。        如果是Innodb引擎表，type列在这个情况通常都是all或者indexeq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高出现在要连接多个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref。ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. 不像eq_ref那样要求连接顺序,也没有主键和唯一索引的要求,只要使用相等条件检索时就可能出现。常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现。总之，返回数据不唯一的等值查找就可能出现。   ref可以用于使用=或&lt;=&gt;操作符的带索引的列。fulltext全文索引的优先级很高,若全文索引和普通索引同时存在时,mysql不管代价，优先选择使用全文索引ref_or_null该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。实际用的不多。5.7版本貌似已经废弃了,unique_subquery该类型替换了下面形式的IN子查询的ref：value IN (SELECT primary_key FROM single_table WHERE some_expr)子查询返回不重复值唯一值.unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。index_subquery该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：value IN (SELECT key_column FROM single_table WHERE some_expr)range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个index_merge该联接类型表示使用了索引合并优化方法。表示查询使用了两个以上的索引,最后取交集或者并集,常见and,or的条件使用了不同的索引。官方排序这个在ref_or_null之后，但是实际上由于要读取所有索引，性能可能大部分时间都不如rangeindex: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index通常比ALL快,因为索引文件通常比数据文件小。可以使用索引排序或者分组的查询以及覆盖索引查询。ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。需要避免的类型,效率最低。可以根据查询条件新增或者调整索引。</code></pre><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</p><pre><code>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。</code></pre><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><pre><code>select_type为index_merge时，这里可能出现两个以上的索引。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引,在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</code></pre><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><pre><code>字符串    char(n): n 字节长度    varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.数值类型:    TINYINT: 1字节    SMALLINT: 2字节    MEDIUMINT: 3字节    INT: 4字节    BIGINT: 8字节时间类型    DATE: 3字节    TIMESTAMP: 4字节    DATETIME: 8字节</code></pre><p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>   如果是使用的常数等值查询,这里会显示const<br>   如果是连接查询,被驱动表的执行计划这里会显示驱动表的关联字段<br>   如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>  rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>  这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>   EXplain 中的很多额外的信息会在 Extra 字段显示,包含有关MySQL如何解析查询的其他信息。<br>   此字段能够给出让我们深入理解执行计划进一步的细节信息，比如是否使用ICP，MRR等<br>   常见的有以下几种内容:</p><pre><code>Using filesort排序时无法使用到索引，常见于order by和group by语句中,此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行。出现这个,查询就需要优化了,MYSQL需要进行额外的步骤来对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行.这并不代表着真的使用了文件排序！当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.Using index查询无需回表，直接通过索引就可以获取查询的数据,不用扫描表数据文件,即覆盖索引！Using temporary表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。发生这种情况一般都是需要进行优化的-般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.Using where表示查询返回的记录并不是所有的都满足查询条件,需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层,不符合检查条件和限制条件的数据，直接不读取,这样就大大减少了存储引擎扫描的记录数量。extra列显示using index conditionUsing sort_union(...)/Using union(...)/Using intersect(...)using intersect：表示使用and多个索引查询时,从处理结果获取交集using union：表示使用or多个索引查询时,从处理结果获取并集using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时,先查询主键,然后进行排序合并后,才能读取记录并返回。using intersect：表示使用and多个索引查询时,从处理结果获取交集using union：表示使用or多个索引查询时,从处理结果获取并集using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时,先查询主键,然后进行排序合并后,才能读取记录并返回。Using index for group-by表明可以在索引中找到分组所需的所有数据，不需要查询实际的表。 注意,这里是非主键！using join buffer（block nested loop），using join buffer（batched key accss）5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。firstmatch(tb_name)5.6.x开始引入的优化子查询的新特性之一,常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个loosescan(m..n)5.6.x之后引入的优化子查询的新特性之一,在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个impossible where:where子句的值总是false，不能用来获取任何元组select tables optimized away：在没有group by子句的情况下，基于索引优化Min、max操作或者对于MyISAM存储引擎优化count（*），不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</code></pre><p>###<br>版本5.7以前，该项是解释分区显示的选项，5.7以后成为了默认选项。该列显示的为分区表命中的分区情况。非分区表该字段为空（null）。</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><pre><code>使用explain extended时会出现这个列。5.7之后的版本默认就有这个字段。不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例,注意是百分比，不是具体记录数。</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/bingoxubin/article/details/78720976" target="_blank" rel="noopener">https://blog.csdn.net/bingoxubin/article/details/78720976</a></p><p><a href="https://blog.csdn.net/bingoxubin/article/details/78720976" target="_blank" rel="noopener">https://blog.csdn.net/bingoxubin/article/details/78720976</a></p><p><a href="https://blog.csdn.net/itfootball/article/details/44876517" target="_blank" rel="noopener">关闭重启jenkins</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;explain是mysql提供的一个优化sql的命令,在5.6以及以后的版本中,&lt;br&gt;除select,如insert,update和delete均可以使用explain查看执行计划，&lt;br&gt;从而知道mysql是如何处理sql语句，分析查询语句或者表结构的性能瓶颈,&lt;br&gt;本次使用的mysql 版本为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@@version
5.6.38
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是为与5.6之后版本关联起来，所以部分内容可能还会含有其他版本的内容&lt;/p&gt;
&lt;h1 id=&quot;使用方式&quot;&gt;&lt;a href=&quot;#使用方式&quot; class=&quot;headerlink&quot; title=&quot;使用方式&quot;&gt;&lt;/a&gt;使用方式&lt;/h1&gt;&lt;p&gt;在sql语句前面增加 explain 即可,5.6.x版本显示部分字段需要添加部分关键字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;explain SELECT * FROM TABLE_NAME

explain extended SELECT * FROM TABLE_NAME
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="mysql" scheme="blog.virualyz.com/categories/mysql/"/>
    
    
      <category term="explain" scheme="blog.virualyz.com/tags/explain/"/>
    
  </entry>
  
  <entry>
    <title>mac版DBeaver查询出来的日期错误</title>
    <link href="blog.virualyz.com/2019/03/10/2019%E5%B9%B403%E6%9C%8810%E6%97%A515:26:21_mac%E7%89%88DBeaver%E6%9F%A5%E8%AF%A2%E5%87%BA%E6%9D%A5%E7%9A%84%E6%97%A5%E6%9C%9F%E9%94%99%E8%AF%AF/"/>
    <id>blog.virualyz.com/2019/03/10/2019年03月10日15:26:21_mac版DBeaver查询出来的日期错误/</id>
    <published>2019-03-10T04:00:00.000Z</published>
    <updated>2019-03-10T07:50:51.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>通过DBeaver查询出来的日期发现比正常时间多,明明是今天的日期，但是sql查询数据库出来的数据确是明天<br>因此对于使用有很大的影响</p><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要解决mac中DBeaver中查询数据错误的问题解决</p> <a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p> 1:在数据库连接上点击出图示(一般为右键)</p><p> <img src="/10/2019年03月10日15:26:21_mac版DBeaver查询出来的日期错误/1552199583202.jpg" alt="图片"></p><p> 2:在其中修改</p><p> <img src="/10/2019年03月10日15:26:21_mac版DBeaver查询出来的日期错误/WX20190310-144340@2x.png" alt="图片"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p> [<a href="https://blog.csdn.net/qq_40763761/article/details/79729147]" target="_blank" rel="noopener">https://blog.csdn.net/qq_40763761/article/details/79729147]</a>(<a href="https://blog.csdn.net/qq_40763761/article/details/79729147" target="_blank" rel="noopener">https://blog.csdn.net/qq_40763761/article/details/79729147</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;通过DBeaver查询出来的日期发现比正常时间多,明明是今天的日期，但是sql查询数据库出来的数据确是明天&lt;br&gt;因此对于使用有很大的影响&lt;/p&gt;
&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要解决mac中DBeaver中查询数据错误的问题解决&lt;/p&gt;
    
    </summary>
    
      <category term="MAC" scheme="blog.virualyz.com/categories/MAC/"/>
    
    
      <category term="DBeaver" scheme="blog.virualyz.com/tags/DBeaver/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(一)工厂方法模式</title>
    <link href="blog.virualyz.com/2019/03/03/2019%E5%B9%B403%E6%9C%8803%E6%97%A522:05:02-23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/03/03/2019年03月03日22:05:02-23种设计模式(一)工厂方法模式/</id>
    <published>2019-03-03T14:05:02.000Z</published>
    <updated>2019-03-03T14:24:58.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>学习工厂模式<br><a id="more"></a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>工厂方法模式：也叫工厂模式，属于类创建型模式，工厂父类（接口）负责定义产品对象的公共接口，而子类工厂则负责创建具体的产品对象。</p><p>目的：是为了把产品的实例化操作延迟到子类工厂中完成，通过工厂子类来决定究竟应该实例化哪一个产品具体对象。</p><p>工厂方法模式包含四个部分：</p><p>1.抽象产品：产品对象同一的基类，或者是同一的接口。</p><p>2.具体的产品：各个不同的实例对象类</p><p>3.抽象工厂：所有的子类工厂类的基类，或是同一的接口</p><p>4.具体的工厂子类：负责每个不同的产品对象的实际创建</p><h1 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h1><p>具体的实例代码：</p><p>1.抽象的产品类：定义car  交通工具类下：</p><pre><code>package factory.simple;/** * 抽象产品角色 交通工具接口 *  * @author lilin *  */public interface Car {    /**     * 上班函数     */    void gotowork();}</code></pre><p>2.定义实际的产品类，总共定义两个，bike 和bus 分别表示不同的交通工具类</p><pre><code>package factory.simple;/** * 具体产品角色，自行车 *  * @author lilin *  */public class Bike implements Car {    @Override    public void gotowork() {        System.out.println(&quot;骑自行车去上班！&quot;);    }}package factory.simple;/** * @author lilin *  */public class Bus implements Car {    @Override    public void gotowork() {        System.out.println(&quot;坐公交车去上班！&quot;);    }}</code></pre><p>3.抽象的工厂接口定义如下：</p><pre><code>/** *  */package factory.factory;import factory.simple.Car;/** * @author lilin *  */public interface ICarFactory {    /**     * 获取交通工具     *      * @return     */    Car getCar();}</code></pre><p>4.具体的工厂子类，分别为每个具体的产品类创建不同的工厂子类：</p><pre><code>/** *  */package factory.factory;import factory.simple.Bike;import factory.simple.Car;/** * @author lilin *  */public class BikeFactory implements ICarFactory {    @Override    public Car getCar() {        return new Bike();    }}/** *  */package factory.factory;import factory.simple.Bus;import factory.simple.Car;/** * @author lilin *  */public class BusFactory implements ICarFactory {    @Override    public Car getCar() {        return new Bus();    }}</code></pre><p>最后，使用简单的测试类，来验证下 不同的工厂能够产生不同的产品对象：测试类如下：</p><pre><code>/** *  */package factory.factory;import org.testng.annotations.Test;import factory.simple.Car;/** * @author lilin *  */public class TestFactory {    @Test    public void test() {        ICarFactory factory = null;        // bike        factory = new BikeFactory();        Car bike = factory.getCar();        bike.gotowork();        // bus        factory = new BusFactory();        Car bus = factory.getCar();        bus.gotowork();    }}</code></pre><p>打印结果如下：</p><p>骑自行车去上班！<br>坐公交车去上班！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工厂模式，可以理解为：有了很多个工厂方法，自己需要哪一个产品，就调用当前产品的工厂方法，获取相应的具体实例。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/lilin0719/p/5309397.html" target="_blank" rel="noopener">https://www.cnblogs.com/lilin0719/p/5309397.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;学习工厂模式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mac端口占用问题</title>
    <link href="blog.virualyz.com/2019/02/28/2019%E5%B9%B402%E6%9C%8828%E6%97%A521:54:55-mac%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>blog.virualyz.com/2019/02/28/2019年02月28日21:54:55-mac端口占用问题/</id>
    <published>2019-02-28T13:56:04.000Z</published>
    <updated>2019-03-29T06:46:46.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>第一次使用mac,关闭idea时忘记关闭tomcat,这时再次启动tomcat会有提示:</p><pre><code>错误: 代理抛出异常错误: java.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address already in use: JVM_Bind</code></pre><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要解决mac中端口占用问题</p><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>端口xxxx被占用了</p><p>1)打开终端输入:</p><p>2)lsof -i tcp:占用端口;</p><p>找到被占用的数字，我的是<em>**</em>;</p><pre><code>lsof -i tcp:1099;</code></pre><p>3)kill PID;</p><pre><code>kill ****;  </code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_40763761/article/details/79729147" target="_blank" rel="noopener">https://blog.csdn.net/qq_40763761/article/details/79729147</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;第一次使用mac,关闭idea时忘记关闭tomcat,这时再次启动tomcat会有提示:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;错误: 代理抛出异常错误: java.rmi.server.ExportException: Port already in use: 1099; nested exception is: 

java.net.BindException: Address already in use: JVM_Bind
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要解决mac中端口占用问题&lt;/p&gt;
    
    </summary>
    
      <category term="system" scheme="blog.virualyz.com/categories/system/"/>
    
    
      <category term="system" scheme="blog.virualyz.com/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>node使用过程中碰见的问题</title>
    <link href="blog.virualyz.com/2019/02/28/2019%E5%B9%B402%E6%9C%8828%E6%97%A521:37:38-node%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%A2%B0%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>blog.virualyz.com/2019/02/28/2019年02月28日21:37:38-node使用过程中碰见的问题/</id>
    <published>2019-02-28T13:39:02.000Z</published>
    <updated>2019-02-28T13:46:07.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>在使用过程中总会碰见一些hexo的问题,这些问题都是一些微小并且繁杂的问题，记录下来希望对其他朋友有所帮助</p><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要记录本人在使用hexo中碰见的有关hexo的问题</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="在使用新的next主题重新创建静态文件之后-部分文件顺序错乱"><a href="#在使用新的next主题重新创建静态文件之后-部分文件顺序错乱" class="headerlink" title="在使用新的next主题重新创建静态文件之后,部分文件顺序错乱"></a>在使用新的next主题重新创建静态文件之后,部分文件顺序错乱</h3><pre><code>date: 2015-01-19 00:34:14</code></pre><p>就是在文章的 md 文档前面加 date: ，这个时间的格式可以在你 blog 目录下的_config.yml 中通过 date_format: YYYY-MM-DD HH:mm:ss 来指定。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[tps://<a href="http://www.jianshu.com/p/04d31f6c22bd]" target="_blank" rel="noopener">www.jianshu.com/p/04d31f6c22bd]</a>(<a href="https://www.v2ex.com/t/231549）" target="_blank" rel="noopener">https://www.v2ex.com/t/231549）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;在使用过程中总会碰见一些hexo的问题,这些问题都是一些微小并且繁杂的问题，记录下来希望对其他朋友有所帮助&lt;/p&gt;
&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要记录本人在使用hexo中碰见的有关hexo的问题&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="blog.virualyz.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="blog.virualyz.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>mac使用nvm管理node以及npm</title>
    <link href="blog.virualyz.com/2019/02/28/2019%E5%B9%B402%E6%9C%8828%E6%97%A521:30:37-nvm%E7%AE%A1%E7%90%86node/"/>
    <id>blog.virualyz.com/2019/02/28/2019年02月28日21:30:37-nvm管理node/</id>
    <published>2019-02-28T00:00:00.000Z</published>
    <updated>2019-02-28T13:32:18.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>好久没动笔，我想启动我的hexo，并写上一些分享，我通过下载gitlab上的私有仓库，然后转入github中，下载下来并安装好node.js之后，我执行<br>    npm install -g hexo-cli<br>希望可以启动我的hexo，但此时却抛出个异常</p><pre><code>The operation was rejected by your operating system</code></pre><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要解决mac中node的各个版本会有差异，新旧系统兼容，第三方组件与node版本导致的全局版本混乱等等，所以通过nvm管理起来,网上查询了下资料,有人说可以不卸载直接安装,为了保险起见，我先卸载了，对于不卸载的朋友，请斟酌后再试。</p><a id="more"></a><h2 id="nvm介绍"><a href="#nvm介绍" class="headerlink" title="nvm介绍"></a>nvm介绍</h2><p>nvm是node版本管理工具，主要特点：</p><p>1.可安装多版本的node。</p><p>2.灵活切换当前的node版本。</p><p>3.以沙箱方式全局安装第三方组件到对应版本的node中。</p><p>4.通过.vnmrc文件，方便灵活地指定各应用系统所需的node版本进行运行。</p><p>直接支持linux，OS系统。windows系统需要使用nvm-windows：<br><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a></p><p>通过nvm管理node，如果之前通过安装包安装推荐删除，如果不删除也不影响安装，只有在别人使用你的电脑的另外账户时会有问题。具体的注意事项可以参考：<br><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">https://github.com/creationix/nvm</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="卸载之前的node-js"><a href="#卸载之前的node-js" class="headerlink" title="卸载之前的node.js"></a>卸载之前的node.js</h3><p>如果通过<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">node</a>下载的安装包进行安装，在终端输入以下命令：</p><pre><code>sudo rm -rf                 /usr/local/{bin/{node,npm},lib/node_modules/npm,lib/node,share/man/*/node.*}</code></pre><p>如果是从brew安装的, 运行brew uninstall node</p><p>如果不是则可以直接删除文件夹</p><p>sudo rm /usr/local/bin/npm<br>sudo rm/usr/local/share/man/man1/node.1<br>sudo rm /usr/local/lib/dtrace/node.d<br>sudo rm -rf ~/.npm<br>sudo rm -rf ~/.node-gyp<br>sudo rm /opt/local/bin/node<br>sudo rm /opt/local/include/node<br>sudo rm -rf /opt/local/lib/node_modules</p><h4 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h4><p>安装nvm可以通过两个命令</p><pre><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</code></pre><p>或者</p><pre><code>wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</code></pre><h4 id="查看安装"><a href="#查看安装" class="headerlink" title="查看安装"></a>查看安装</h4><p>安装完毕后输入nvm，当有一段输出并没有明显的报错时，代表安装成功。<br>博主通过命令安装后，自动在 .bash_profile 文件内添加了</p><pre><code>export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot; $NVM_DIR/nvm.sh&quot;</code></pre><p>如果你没有添加，可以手动添加<br>然后 source 一下 .bash_profile</p><pre><code>source .bash_profile</code></pre><h4 id="安装版本"><a href="#安装版本" class="headerlink" title="安装版本"></a>安装版本</h4><pre><code>nvm install stable # 安装最新稳定版 nodenvm install 10.15.1 # 安装 10.15.1 版本</code></pre><p>查看nvm版本：打开新的终端，用nvm current查看当前版本显示</p><p>删除指定版本 node：nvm uninstall v10.15.1</p><p>使用指定版本 node：nvm use v10.15.1</p><p>切换到最新版：<br>nvm use node</p><pre><code>我们给 10.15.1 这个版本号起了一个名字叫做 my-versionnvm alias my-version 10.15.1</code></pre><p>然后我们可以运行：</p><pre><code>nvm use my-version</code></pre><p>下面这个命令可以取消别名：</p><pre><code>nvm unalias my-version</code></pre><p>另外，你还可以设置 default 这个特殊别名：</p><pre><code>nvm alias default node</code></pre><p>列出已安装实例</p><pre><code>nvm ls</code></pre><h2 id="碰到的问题以及解决方法"><a href="#碰到的问题以及解决方法" class="headerlink" title="碰到的问题以及解决方法"></a>碰到的问题以及解决方法</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">https://github.com/creationix/nvm</a><br><a href="https://blog.csdn.net/hahahhahahahha123456/article/details/85220526" target="_blank" rel="noopener">https://blog.csdn.net/hahahhahahahha123456/article/details/85220526</a><br><a href="https://www.jianshu.com/p/04d31f6c22bd" target="_blank" rel="noopener">https://www.jianshu.com/p/04d31f6c22bd</a><br><a href="https://www.jianshu.com/p/04d31f6c22bd" target="_blank" rel="noopener">https://www.jianshu.com/p/04d31f6c22bd</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;好久没动笔，我想启动我的hexo，并写上一些分享，我通过下载gitlab上的私有仓库，然后转入github中，下载下来并安装好node.js之后，我执行&lt;br&gt;    npm install -g hexo-cli&lt;br&gt;希望可以启动我的hexo，但此时却抛出个异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The operation was rejected by your operating system
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要解决mac中node的各个版本会有差异，新旧系统兼容，第三方组件与node版本导致的全局版本混乱等等，所以通过nvm管理起来,网上查询了下资料,有人说可以不卸载直接安装,为了保险起见，我先卸载了，对于不卸载的朋友，请斟酌后再试。&lt;/p&gt;
    
    </summary>
    
      <category term="mvn" scheme="blog.virualyz.com/categories/mvn/"/>
    
    
      <category term="mvn" scheme="blog.virualyz.com/tags/mvn/"/>
    
  </entry>
  
  <entry>
    <title>mac中git创建秘钥</title>
    <link href="blog.virualyz.com/2018/10/06/201810061650-git%E5%88%9B%E5%BB%BA%E7%A7%98%E9%92%A5/"/>
    <id>blog.virualyz.com/2018/10/06/201810061650-git创建秘钥/</id>
    <published>2018-10-06T08:50:03.000Z</published>
    <updated>2019-03-30T13:40:05.641Z</updated>
    
    <content type="html"><![CDATA[<p>#背景<br>从git上通过idea工具clone了一个项目，但是在提交代码的时候发现提示错误，错误代码大致如下</p><pre><code>git@github.com: Permission denied (publickey)</code></pre><p>找了下原因发现是没有公钥导致的，之前安装git并clone下代码之后没有进行提交，觉得没问题了，发现还是省不得操作啊。</p><p>#解决方法</p><p>通过生成一个公钥配置到git账号里面的ssh那个菜单就ok了</p><a id="more"></a><p>#具体步骤</p><p>1.通过ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>进行测试查看有没有公钥，如果没提示就会出现和我一样的情况</p><p>2.通过命令直接生成公钥</p><pre><code>ssh-keygen -t rsa -b 2048 -C “youreamil@email.com” </code></pre><p>3.执行完之后会出，此步是让你输入自定义的文件名，这里不用管他，默认就好，直接回车进行下一步骤</p><pre><code>Generating public/private rsa key pair. Enter file in which to save the key (/home/xxx/.ssh/id_rsa):</code></pre><p>4.然后会出现如下提示，这步是让你输入一个密码，密码会在提交代码使用(这里除了下面一步，我提交代码时没使用这个密码)，不想设置就直接回车(这步我没有尝试)，如果不能默认<br>那就输入一个然后记住吧。与git密码相同好记忆</p><pre><code>Enter passphrase (empty for no passphrase): Enter same passphrase again: </code></pre><p>5.然后就创建成功了你会看到提示，还有其他一些输出，这里就不写了</p><pre><code>Your identification has been saved in /home/xxx/.ssh/id_rsa. Your public key has been saved in /home/xxx/.ssh/id_rsa.pub. </code></pre><p>6.在成功后把秘钥交给ssh-agent管理</p><pre><code>ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序。ssh-agent是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。</code></pre><p>   先确认ssh-agent处于启用状态： </p><pre><code>eval “$(ssh-agent -s)”</code></pre><p>   输出类似于：</p><pre><code>Agent pid xxxxx</code></pre><p>   然后将SSH key添加到ssh-agent：</p><pre><code>ssh-add ~/.ssh/id_rsa</code></pre><p>   这时又会要你输入上面定义的密码：</p><pre><code>Enter passphrase for /home/xxx/.ssh/id_rsa: </code></pre><p>   输入，回车</p><p>7.打开秘钥所在文件/.ssh,找到默认文件id_rsa.pub</p><pre><code>open ～/.ssh  </code></pre><p>8.把文件内容复制，并添加到你邮件注册的git中，具体路径 git登陆-&gt;settings-&gt;ssh and GPG keys-&gt;new ssh key -&gt; title 随便输入，自己认识就好，key 填写之前生成的公钥-&gt;保存</p><p>9.完毕</p><p>#碰到的问题以及解决方法</p><p>1.mac中直接访达当爱你用户文件找不到/.ssh,通过命令行打开的<br>2.提交代码出现提示，找了下是host没有地址xxx所致，加进去就好了(这个错误在我这里偶尔出现)</p><pre><code>Warning: Permanently added the RSA host key for IP address &apos;xxxxxxxx&apos; to the list of known hosts.</code></pre><p>   解决：</p><pre><code>vim /etc/hosts</code></pre><p>   添加一行：xxx.xxx.xxx.xxx　　github.com</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#背景&lt;br&gt;从git上通过idea工具clone了一个项目，但是在提交代码的时候发现提示错误，错误代码大致如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git@github.com: Permission denied (publickey)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;找了下原因发现是没有公钥导致的，之前安装git并clone下代码之后没有进行提交，觉得没问题了，发现还是省不得操作啊。&lt;/p&gt;
&lt;p&gt;#解决方法&lt;/p&gt;
&lt;p&gt;通过生成一个公钥配置到git账号里面的ssh那个菜单就ok了&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="blog.virualyz.com/categories/git/"/>
    
    
      <category term="git" scheme="blog.virualyz.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>centOS7安装docker</title>
    <link href="blog.virualyz.com/2018/09/24/201809241939-centOS7%E5%AE%89%E8%A3%85docker/"/>
    <id>blog.virualyz.com/2018/09/24/201809241939-centOS7安装docker/</id>
    <published>2018-09-24T11:40:31.000Z</published>
    <updated>2019-02-24T07:47:44.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p><p>一个完整的Docker有以下几个部分组成：</p><ul><li>dockerClient客户端</li><li>Docker Daemon守护进程</li><li>Docker Image镜像</li><li>DockerContainer容器</li></ul><p>另:docker分为社区版CE和企业版EE。<br>社区版是免费提供给个人开发者和小型团体使用的。<br>企业版会提供额外的收费服务，比如插件等。<br>社区版按照stable和edge两种方式发布，每个季度更新stable版本，比如3月6月；每个月份更新edge版本，如1月，2月</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>1.确认当前系统支持安装(我这里用centOS，Docker 要求 CentOS 系统的内核版本高于 3.10 )<br>2.查看是否已经安装，如果是你已经安装，可以自行确认下可否使用，也可以移除已安装<br>3.选择docker版本并安装其他支持<br>4.验证</p><a id="more"></a> <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>1.yum源:<a href="https://download.docker.com/linux/centos/docker-ce.repo(也可以选择阿里源)" target="_blank" rel="noopener">https://download.docker.com/linux/centos/docker-ce.repo(也可以选择阿里源)</a></p><p>2.想要安装的docker版本</p><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><p>1.查看系统信息</p><pre><code>uname -r</code></pre><p>2.用root账户操作</p><pre><code>sudo su</code></pre><p>3.安装需要的软件包</p><pre><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>4.设置yum源</p><pre><code>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p>5.可以查看仓库中所有docker版本，并选择版本安装</p><pre><code>yum list docker-ce --showduplicates | sort -r</code></pre><p>   <img src="/24/201809241939-centOS7安装docker/docker-ce版本.png" alt="docker-ce版本"></p><p>6.安装docker</p><pre><code>yum install docker-ce-17.12.0.ce</code></pre><p>7.验证安装是否成功</p><pre><code>docker version</code></pre><p>8.增加开机启动</p><pre><code>systemctl start dockersystemctl enable docker</code></pre><p>   查看</p><pre><code>systemctl status docker.service</code></pre><p>   <img src="/24/201809241939-centOS7安装docker/docker开机启动.png" alt="docker开机启动"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://baike.baidu.com/item/Docker/13344470?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/Docker/13344470?fr=aladdin</a><br><a href="https://www.cnblogs.com/yufeng218/p/8370670.html" target="_blank" rel="noopener">https://www.cnblogs.com/yufeng218/p/8370670.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;
&lt;p&gt;一个完整的Docker有以下几个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dockerClient客户端&lt;/li&gt;
&lt;li&gt;Docker Daemon守护进程&lt;/li&gt;
&lt;li&gt;Docker Image镜像&lt;/li&gt;
&lt;li&gt;DockerContainer容器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另:docker分为社区版CE和企业版EE。&lt;br&gt;社区版是免费提供给个人开发者和小型团体使用的。&lt;br&gt;企业版会提供额外的收费服务，比如插件等。&lt;br&gt;社区版按照stable和edge两种方式发布，每个季度更新stable版本，比如3月6月；每个月份更新edge版本，如1月，2月&lt;/p&gt;
&lt;h2 id=&quot;大致流程&quot;&gt;&lt;a href=&quot;#大致流程&quot; class=&quot;headerlink&quot; title=&quot;大致流程&quot;&gt;&lt;/a&gt;大致流程&lt;/h2&gt;&lt;p&gt;1.确认当前系统支持安装(我这里用centOS，Docker 要求 CentOS 系统的内核版本高于 3.10 )&lt;br&gt;2.查看是否已经安装，如果是你已经安装，可以自行确认下可否使用，也可以移除已安装&lt;br&gt;3.选择docker版本并安装其他支持&lt;br&gt;4.验证&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>idea创建maven项目--helloWord</title>
    <link href="blog.virualyz.com/2018/09/09/201809091735-idea%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE-helloWord/"/>
    <id>blog.virualyz.com/2018/09/09/201809091735-idea创建maven项目-helloWord/</id>
    <published>2018-09-09T09:36:48.000Z</published>
    <updated>2019-02-24T07:47:44.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。<br>Maven 是一个构建项目十分方便的工具，并且提供许多项目管理的高级功能</p><h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>1.idea</p><p>2.maven（此项可以省略）</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>1.打开idea，在选项卡中选择file-&gt;new-&gt;Project,选择并填写相关信息，确认保存</p><p>2.配置tomcat启动<br><a id="more"></a> </p><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><p>1.打开idea，在选项卡中选择file-&gt;new-&gt;Project</p><p>2.选择maven,选中create from archetype,在列表中找到图示选项,next<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea创建maven项目选项.png" alt="idea创建maven项目选项"></p><p>3.输入groupId,artifactId<br>GroupID实际对应JAVA的包的结构，是main目录里java的目录结构。 ArtifactID就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea创建maven项目填写.png" alt="idea创建maven项目填写"></p><p>4.这步可以直接next，这时使用的maven版本就是idea自带的，如果不想使用，可以选择，也可以自定义setting文件路径<br>，以及本地的仓库路径<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea创建maven项目选择版本.png" alt="idea创建maven项目选择版本"></p><p>5.然后就是项目名以及项目路径，可以不改，直接next<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea创建maven项目项目名以及路径.png" alt="idea创建maven项目项目名以及路径"></p><p>项目创建完，我们来尝试启动它看看他的效果</p><p>6.然后进入配置，一种通过选项卡点击run-&gt;Edit Configurations,另一种选择<br>idea右上角的图示位置点击，然后选择Edit Configurations<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea配置tomcat启动EditConfigurations.png" alt="idea配置tomcat启动EditConfigurations"></p><p>7.在Edit Configurations按照图示顺序选择<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea配置tomcat启动.png" alt="idea配置tomcat启动"></p><p>8.选择Artifact<br>Artifact 是maven中的一个概念，表示某个module要如何打包。例如war exploded、war、jar、ear等等这种打包形式；<br>一个module有了 Artifacts 就可以部署到应用服务器中了！</p><p>至于带不带的区别，explode 在这里你可以理解为展开，不压缩的意思。也就是war、jar等产出物没压缩前的目录结构。<br>建议在开发的时候使用这种模式，便于修改了文件的效果立刻显现出来。<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea配置tomcat启动选择Artifact.png" alt="idea配置tomcat启动选择Artifact"><br><img src="/09/201809091735-idea创建maven项目-helloWord/idea配置tomcat启动选择Artifact文件.png" alt="idea配置tomcat启动选择Artifact文件"></p><p>9.最后启动你的项目，你就会看到这样的效果啦<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea配置tomcat启动成功页面.png" alt="idea配置tomcat启动成功页面"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_27093465/article/details/76091287" target="_blank" rel="noopener">https://blog.csdn.net/qq_27093465/article/details/76091287</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。&lt;br&gt;Maven 是一个构建项目十分方便的工具，并且提供许多项目管理的高级功能&lt;/p&gt;
&lt;h1 id=&quot;执行&quot;&gt;&lt;a href=&quot;#执行&quot; class=&quot;headerlink&quot; title=&quot;执行&quot;&gt;&lt;/a&gt;执行&lt;/h1&gt;&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;1.idea&lt;/p&gt;
&lt;p&gt;2.maven（此项可以省略）&lt;/p&gt;
&lt;h2 id=&quot;大致流程&quot;&gt;&lt;a href=&quot;#大致流程&quot; class=&quot;headerlink&quot; title=&quot;大致流程&quot;&gt;&lt;/a&gt;大致流程&lt;/h2&gt;&lt;p&gt;1.打开idea，在选项卡中选择file-&amp;gt;new-&amp;gt;Project,选择并填写相关信息，确认保存&lt;/p&gt;
&lt;p&gt;2.配置tomcat启动&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="maven" scheme="blog.virualyz.com/categories/maven/"/>
    
    
      <category term="maven" scheme="blog.virualyz.com/tags/maven/"/>
    
  </entry>
  
</feed>
