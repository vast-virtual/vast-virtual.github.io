<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.virualyz.com/"/>
  <updated>2019-04-14T13:53:45.765Z</updated>
  <id>blog.virualyz.com/</id>
  
  <author>
    <name>xcxd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>23种设计模式(五)原型模式</title>
    <link href="blog.virualyz.com/2019/04/14/2019-04-13_21-54-47_23%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%94)%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/04/14/2019-04-13_21-54-47_23中设计模式(五)原型模式/</id>
    <published>2019-04-14T08:00:00.000Z</published>
    <updated>2019-04-14T13:53:45.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>原型模式(Prototype Pattern)</p><a id="more"></a><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式是一种创建型设计模式，原型模式(Prototype)允许一个对象再创建另外一个可定制的对象，<br>根本无需知道任何如何创建的细节</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象</p><h1 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h1><p>在这样的设计模式中，有以下几个角色：</p><p>1、客户（Client）角色：客户端类向原型管理器提出创建对象的请求</p><p>2、抽象原型（Prototype）角色：这是一个抽象角色，通常由一个C#接口或抽象类实现。此角色给出所有的具体原型类所需的接口。在C#中，抽象原型角色通常实现了ICloneable接口。</p><p>3、具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。</p><p>4、原型管理器（Prototype Manager）角色：创建具体原型类的对象，并记录每一个被创建的对象。</p><h1 id="基本的实现思路"><a href="#基本的实现思路" class="headerlink" title="基本的实现思路"></a>基本的实现思路</h1><p>通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、当创建的对象实例较为复杂的时候，使用原型模式可以简化对象的创建过程！</p><p>2、扩展性好，由于写原型模式的时候使用了抽象原型类，在客户端进行编程的时候可以将具体的原型类通过配置进行读取。</p><p>3、可以使用深度克隆来保存对象的状态，使用原型模式进行复制。当你需要恢复到某一时刻就直接跳到。比如我们的idea种就有历史版本，或则SVN中也有这样的操作。非常好用！</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1、需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的里面，当对已有的类经行改造时需要修改源代码，违背了开闭原则。</p><p>2、在实现深克隆的时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用的时候，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现相对麻烦。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>1、当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 [1] </p><p>2、当构造过程必须允许被构造的对象有不同表示时。</p><h1 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h1><p>1创建对象成本比较大，比如初始化要很长时间的，占用太多CPU的，新对象可以通过复制已有的对象获得的，如果是相似的对象，则可以对其成员变量稍作修改。</p><p>2系统要保存对象状态的，而对象的状态改变很小。</p><p>3需要避免使用分层次的工厂类来创建分层次的对象，并且类的对象就只用一个或很少的组合状态！</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>1、创建一个实现了 Cloneable 接口的抽象类。</p><pre><code>public abstract class Shape implements Cloneable {   private String id;   protected String type;   abstract void draw();   public String getType(){      return type;   }   public String getId() {      return id;   }   public void setId(String id) {      this.id = id;   }   public Object clone() {      Object clone = null;      try {         clone = super.clone();      } catch (CloneNotSupportedException e) {         e.printStackTrace();      }      return clone;   }}</code></pre><p>2、创建扩展了上面抽象类的实体类</p><pre><code>public class Rectangle extends Shape {   public Rectangle(){     type = &quot;Rectangle&quot;;   }   @Override   public void draw() {      System.out.println(&quot;Inside Rectangle::draw() method.&quot;);   }}public class Square extends Shape {   public Square(){     type = &quot;Square&quot;;   }   @Override   public void draw() {      System.out.println(&quot;Inside Square::draw() method.&quot;);   }}public class Circle extends Shape {   public Circle(){     type = &quot;Circle&quot;;   }   @Override   public void draw() {      System.out.println(&quot;Inside Circle::draw() method.&quot;);   }}</code></pre><p>3、创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中</p><pre><code>import java.util.Hashtable;public class ShapeCache {   private static Hashtable&lt;String, Shape&gt; shapeMap       = new Hashtable&lt;String, Shape&gt;();   public static Shape getShape(String shapeId) {      Shape cachedShape = shapeMap.get(shapeId);      return (Shape) cachedShape.clone();   }   // 对每种形状都运行数据库查询，并创建该形状   // shapeMap.put(shapeKey, shape);   // 例如，我们要添加三种形状   public static void loadCache() {      Circle circle = new Circle();      circle.setId(&quot;1&quot;);      shapeMap.put(circle.getId(),circle);      Square square = new Square();      square.setId(&quot;2&quot;);      shapeMap.put(square.getId(),square);      Rectangle rectangle = new Rectangle();      rectangle.setId(&quot;3&quot;);      shapeMap.put(rectangle.getId(),rectangle);   }}</code></pre><p>4、PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆</p><pre><code>public class PrototypePatternDemo {   public static void main(String[] args) {      ShapeCache.loadCache();      Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;);      System.out.println(&quot;Shape : &quot; + clonedShape.getType());              Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;);      System.out.println(&quot;Shape : &quot; + clonedShape2.getType());              Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;);      System.out.println(&quot;Shape : &quot; + clonedShape3.getType());           }}</code></pre><p>5、客户端类代码片段：</p><p>   在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><pre><code>package com.test.builder;public class TestMain {    //something    Builder builder = new ConcreteBuilder();    Director director = new Director(builder);    Product product = director.construct();    //something}</code></pre><p>输出结果：</p><pre><code>Shape : CircleShape : SquareShape : Rectangle</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/4941014?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/4941014?fr=aladdin</a><br><a href="https://blog.csdn.net/qq_40709468/article/details/82316418" target="_blank" rel="noopener">https://blog.csdn.net/qq_40709468/article/details/82316418</a><br><a href="http://www.runoob.com/design-pattern/prototype-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/prototype-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;原型模式(Prototype Pattern)&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(四)建造者(生成器)模式</title>
    <link href="blog.virualyz.com/2019/04/07/2019-04-07_19-08-37_23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E5%9B%9B)%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/04/07/2019-04-07_19-08-37_23种设计模式(四)建造者模式/</id>
    <published>2019-04-07T10:00:00.000Z</published>
    <updated>2019-04-14T13:53:19.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>学习建造者(生成器)模式(builder Pattern)</p><a id="more"></a><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式，又名生成器模式，是一种软件设计模式，<br>属于创建型模式。建造者模式将一个复杂对象的构建与它的表示分离，<br>使得同样的构建过程可以创建不同的表示(属性)。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节</p><h1 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h1><p>在这样的设计模式中，有以下几个角色：</p><p>1、builder（抽象建造者）：为创建一个产品对象的各个部件指定抽象接口。</p><p>2、ConcreteBuilder（具体建造者）：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。</p><p>3、Director（指挥者）：构造一个使用Builder接口的对象。 它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程</p><p>4、Product（产品角色）：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</p><h1 id="基本的实现思路"><a href="#基本的实现思路" class="headerlink" title="基本的实现思路"></a>基本的实现思路</h1><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1、不必知道产品内部组成的细节，产品的建造和表示分离，实现了解耦。</p><p>2、隐藏了产品的建造细节，用户只需关心产品的表示，而不需要了解是如何创建产品的。</p><p>3、每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 </p><p>4、可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</p><p>5、体现了开闭原则，增加新的具体建造者无须修改原有建造者代码，指挥者类针对抽象建造者类编程，扩展方便</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1、当建造者过多时，会产生很多类，难以维护。</p><p>2、产品之间差异性很大的情况：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制</p><p>3、产品内部变化很复杂的情况：产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>1、当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 [1] </p><p>2、当构造过程必须允许被构造的对象有不同表示时。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>1、一个典型的复杂对象其类代码示例如下：</p><pre><code>package com.test.builder;public class Product {    /**     * 可以是任意类型     */    private String partA;    private String partB;    private String partC;    public String getPartA() {        return partA;    }    public void setPartA(String partA) {        this.partA = partA;    }    public String getPartB() {        return partB;    }    public void setPartB(String partB) {        this.partB = partB;    }    public String getPartC() {        return partC;    }    public void setPartC(String partC) {        this.partC = partC;    }}</code></pre><p>2、抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：</p><pre><code>public abstract class Builder{    protected Product product=new Product();    public abstract void buildPartA();    public abstract void buildPartB();    public abstract void buildPartC();    public Product getResult()    {        return product;    }}</code></pre><p>3、具体建造者。实现抽象接口，构建和装配各个部件,实例代码如下：</p><pre><code>package com.test.builder;public class ConcreteBuilder extends Builder{    @Override    public void buildPartA(){    //something    }    @Override    public void buildPartB(){    //something    }    @Override    public void buildPartC(){    //something    }}</code></pre><p>4、指挥者类的代码示例如下：<br>  建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p><pre><code>package com.test.builder;/** * Director * * @author xxx */public class Director {    private Builder builder;    /**     * 1构造方法的方式注入builder对象     * @param builder     */    public Director(Builder builder)    {        this.builder = builder;    }    /**     * 2 set方法注入builder对象     * @param builder     */    public void setBuilder(Builder builder)    {        this.builder = builder;    }    public Product construct()    {        builder.buildPartA();        builder.buildPartB();        builder.buildPartC();        return builder.getResult();    }}</code></pre><p>5、客户端类代码片段：</p><p>   在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><pre><code>package com.test.builder;public class TestMain {    //something    Builder builder = new ConcreteBuilder();    Director director = new Director(builder);    Product product = director.construct();    //something}</code></pre><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="贩卖不同内容的纸"><a href="#贩卖不同内容的纸" class="headerlink" title="贩卖不同内容的纸"></a>贩卖不同内容的纸</h2><p>建造者模式可以用于描述创建不同内容的纸张<br>一张纸上的内容一般包含很多内容，按照头部，身体 脚等区分内容<br>不同的纸有不同的组成内容，可以根据顾客的要求，<br>一步一步装配这些组成部分，构造一份客户需要的内容的纸给他。</p><h3 id="Product（产品角色）"><a href="#Product（产品角色）" class="headerlink" title="Product（产品角色）"></a>Product（产品角色）</h3><p>具体的产品对象</p><pre><code>package com.test.test;public class Paper {    private String head;    private String body;    private String hand;    private String foot;    public String getHead() {        return head;    }    public void setHead(String head) {        this.head = head;    }    public String getBody() {        return body;    }    public void setBody(String body) {        this.body = body;    }    public String getHand() {        return hand;    }    public void setHand(String hand) {        this.hand = hand;    }    public String getFoot() {        return foot;    }    public void setFoot(String foot) {        this.foot = foot;    }}</code></pre><h3 id="Builder（抽象建造者）"><a href="#Builder（抽象建造者）" class="headerlink" title="Builder（抽象建造者）"></a>Builder（抽象建造者）</h3><p>创建一个Product对象的各个部件指定的抽象接口。</p><pre><code>package com.test.test;public abstract class PaperBuilder {    Paper paper = new Paper();    public abstract void buildHead();    public abstract void buildBody();    public abstract void builHand();    public abstract void buildFoot();    public Paper getPaper(){        return paper;    }}</code></pre><h3 id="ConcreteBuilder（具体建造者）"><a href="#ConcreteBuilder（具体建造者）" class="headerlink" title="ConcreteBuilder（具体建造者）"></a>ConcreteBuilder（具体建造者）</h3><p>实现抽象接口，构建和装配各个部件</p><p>纸张A</p><pre><code>package com.test.test;public class PaperA extends PaperBuilder{    @Override    public void buildHead(){        paper.setHead(&quot;A&quot;);    }    @Override    public void buildBody(){        paper.setBody(&quot;类型1&quot;);    }    @Override    public void builHand(){        paper.setHand(&quot;无手&quot;);    }    @Override    public void buildFoot(){        paper.setFoot(&quot;42码的脚&quot;);    }}</code></pre><p>纸张B</p><pre><code>package com.test.test;public class PaperB extends PaperBuilder{    @Override    public void buildHead(){        paper.setHead(&quot;B&quot;);    }    @Override    public void buildBody(){        paper.setBody(&quot;类型2&quot;);    }    @Override    public void builHand(){        paper.setHand(&quot;有手&quot;);    }    @Override    public void buildFoot(){        paper.setFoot(&quot;24码的脚&quot;);    }}</code></pre><h3 id="Director（指挥者）"><a href="#Director（指挥者）" class="headerlink" title="Director（指挥者）"></a>Director（指挥者）</h3><p>构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象，它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程</p><pre><code>package com.test.test;public class PaperDirector {    private PaperBuilder PaperBuilder;    public PaperDirector(PaperBuilder PaperBuilder) {        this.PaperBuilder = PaperBuilder;    }    public Paper construct(){        //        PaperBuilder.buildHead();        //        PaperBuilder.buildBody();        //        PaperBuilder.builHand();        //        PaperBuilder.buildFoot();        //准备完毕，返回一个完整的纸给客户        return PaperBuilder.getPaper();    }}</code></pre><h3 id="测试类-客户端类"><a href="#测试类-客户端类" class="headerlink" title="测试类(客户端类)"></a>测试类(客户端类)</h3><pre><code>package com.test.test;public class Test {    public static void main(String[] args) {        //纸A        PaperA a = new PaperA();        //准备纸A的管理者        PaperDirector waiter = new PaperDirector(a);        //获得套餐        Paper PaperA = waiter.construct();        System.out.print(&quot;纸A的组成部分:&quot;);        System.out.println(&quot;头：&quot;+PaperA.getHead()+&quot;；   &quot;+&quot;身体：&quot;+PaperA.getBody()+&quot;；   &quot; + &quot;手：&quot; + PaperA.getHand()+&quot;；   &quot; + &quot;脚：&quot; + PaperA.getFoot());    }}</code></pre><p>输出结果：</p><pre><code>纸A的组成部分:头：A；   身体：类型1；   手：无手；   脚：42码的脚</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>建造者模式的使用场合是当创建复杂对象时，把创建对象成员和装配方法分离出来，放在建造者类中去实现，用户使用该复杂对象时，不用理会它的创建和装配过程，只关心它的表示形式</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baike.baidu.com/item/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/3229729" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/3229729</a><br><a href="https://www.cnblogs.com/jenkinschan/p/6426694.html" target="_blank" rel="noopener">https://www.cnblogs.com/jenkinschan/p/6426694.html</a><br><a href="https://blog.csdn.net/u010102390/article/details/80179754" target="_blank" rel="noopener">https://blog.csdn.net/u010102390/article/details/80179754</a><br><a href="https://www.cnblogs.com/snailclimb/p/builderpattern.html" target="_blank" rel="noopener">https://www.cnblogs.com/snailclimb/p/builderpattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;学习建造者(生成器)模式(builder Pattern)&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(三)单例模式</title>
    <link href="blog.virualyz.com/2019/04/06/2019-04-06_20-40-38_23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%89)%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/04/06/2019-04-06_20-40-38_23种设计模式(三)单例模式/</id>
    <published>2019-04-06T12:00:00.000Z</published>
    <updated>2019-04-14T13:52:38.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>学习单例模式(Singleton pattern)<br><a id="more"></a></p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式，是一种常用的软件设计模式，是最简单的设计模式之一，<br>属于创建型模式，它提供了一种创建对象的最佳方式。在它的核心结构中只包含一个被称为<br>单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个<br>实例。即一个类只有一个对象实例。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，<br>可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一<br>实例的机制，“阻止”所有想要生成对象的访问。使用工厂方法来限制实例化过<br>程。这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一<br>实例毫无意义。</p><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>对于系统中的某些类来说，只有一个实例很重要。如：一个系统只能有一个任务管理器，<br>如果有多个一样的任务管理会造成资源浪费，如果有多个不一样的任务管理器，会造成<br>分辨困难，乃至无法分辨。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？<br>定义一个全局变量可以确保对象随时都可以被访问，<br>但不能防止我们实例化多个对象。<br>一个更好的解决办法是让类自身负责保存它的唯一实例。<br>这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。<br>这就是单例模式的模式动机。</p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>1、单例类只能有一个实例</p><p>2、单例类必须自己创建自己的唯一实例</p><p>3、单例类必须自行给所有其他对象提供这一唯一实例</p><h1 id="基本的实现思路"><a href="#基本的实现思路" class="headerlink" title="基本的实现思路"></a>基本的实现思路</h1><p>单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。</p><p>单例的实现主要是通过以下两个步骤：</p><p>1、将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</p><p>2、在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：</p><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例</p><p>2、避免对资源的多重占用（比如写文件操作）</p><p>缺点：</p><p>1、没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p>2、当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，<br>可能会给其他开发人员造成困扰，特别是看不到源码的时候。</p><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>1、需要频繁的进行创建和销毁的对象</p><p>2、创建对象时耗时过多或耗费资源过多，但又经常用到的对象</p><p>3、工具类对象</p><p>4、频繁访问数据库或文件的对象</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>单例模式在多线程的应用场合下必须小心使用。<br>如果当唯一实例尚未创建时，有两个线程同时调用创建方法，<br>那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，<br>这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。<br>解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁<br>(虽然这样会降低效率)。</p><h1 id="单例的各种类型介绍"><a href="#单例的各种类型介绍" class="headerlink" title="单例的各种类型介绍"></a>单例的各种类型介绍</h1><p>通常单例模式在Java语言中，有两种构建方式：</p><p>  饿汉方式：指全局的单例实例在类装载时构建</p><p>  懒汉方式：指全局的单例实例在第一次被使用时构建</p><h2 id="饿汉方式"><a href="#饿汉方式" class="headerlink" title="饿汉方式"></a>饿汉方式</h2><h3 id="饿汉方式：静态常量-推荐"><a href="#饿汉方式：静态常量-推荐" class="headerlink" title="饿汉方式：静态常量-推荐"></a>饿汉方式：静态常量-推荐</h3><p>   类型特点：静态常量</p><p>   问题：无</p><p>   是否建议使用：推荐</p><pre><code>public class Singleton {    private final static Singleton INSTANCE = new Singleton();    //私有构造    private Singleton(){}    public static Singleton getInstance(){        return INSTANCE;    }}</code></pre><p>   优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p><p>   缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p><h3 id="饿汉方式：静态代码块-推荐"><a href="#饿汉方式：静态代码块-推荐" class="headerlink" title="饿汉方式：静态代码块-推荐"></a>饿汉方式：静态代码块-推荐</h3><p>   类型特点：静态代码块</p><p>   问题：无</p><p>   是否建议使用：推荐</p><pre><code>public class Singleton {    private static Singleton instance;    static {        instance = new Singleton();    }    private Singleton() {}    public static Singleton getInstance() {        return instance;    }}</code></pre><p>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h3 id="懒汉式：线程不安全-不推荐"><a href="#懒汉式：线程不安全-不推荐" class="headerlink" title="懒汉式：线程不安全-不推荐"></a>懒汉式：线程不安全-不推荐</h3><p>   类型特点：静态代码块</p><p>   类型问题：线程不安全</p><p>   是否建议使用：不推荐</p><pre><code>public class Singleton {    private static Singleton singleton;    private Singleton() {}    public static Singleton getInstance() {        if (singleton == null) {            singleton = new Singleton();        }        return singleton;    }}</code></pre><p>这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p><h3 id="懒汉式：同步方法-线程安全"><a href="#懒汉式：同步方法-线程安全" class="headerlink" title="懒汉式：同步方法-线程安全"></a>懒汉式：同步方法-线程安全</h3><p>   类型特点：同步方法</p><p>   问题：无（线程安全）</p><p>   是否建议使用：不推荐</p><pre><code>public class Singleton {    private static Singleton singleton;    private Singleton() {}    public static synchronized Singleton getInstance() {        if (singleton == null) {            singleton = new Singleton();        }        return singleton;    }}</code></pre><p>解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。</p><p>缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</p><h3 id="懒汉式：同步代码块-线程安全-不推荐"><a href="#懒汉式：同步代码块-线程安全-不推荐" class="headerlink" title="懒汉式：同步代码块-线程安全-不推荐"></a>懒汉式：同步代码块-线程安全-不推荐</h3><p>   类型特点：同步代码块</p><p>   问题：无（线程安全）</p><p>   是否建议使用：不推荐</p><pre><code>public class Singleton {    private static Singleton singleton;    private Singleton() {}    public static Singleton getInstance() {        if (singleton == null) {            synchronized (Singleton.class) {                singleton = new Singleton();            }        }        return singleton;    }}</code></pre><p>由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</p><h2 id="拓展类型"><a href="#拓展类型" class="headerlink" title="拓展类型"></a>拓展类型</h2><h3 id="双重检查：同步代码块-线程安全-推荐"><a href="#双重检查：同步代码块-线程安全-推荐" class="headerlink" title="双重检查：同步代码块-线程安全-推荐"></a>双重检查：同步代码块-线程安全-推荐</h3><p>   类型特点：同步代码块</p><p>   问题：无（线程安全）</p><p>   是否建议使用：推荐</p><pre><code>public class Singleton {    private static volatile Singleton singleton;    private Singleton() {}    public static Singleton getInstance() {        if (singleton == null) {            synchronized (Singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }}    </code></pre><p>如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。</p><p>优点；延迟加载；效率较高</p><h3 id="静态内部类：推荐"><a href="#静态内部类：推荐" class="headerlink" title="静态内部类：推荐"></a>静态内部类：推荐</h3><p>   类型特点：静态内部类</p><p>   问题：无（线程安全）</p><p>   是否建议使用：推荐</p><pre><code>public class Singleton {    private static volatile Singleton singleton;    private Singleton() {}    public static Singleton getInstance() {        if (singleton == null) {            synchronized (Singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }}  </code></pre><p>种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</p><p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p><p>优点：延迟加载，效率较高。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code>public enum Singleton {    INSTANCE;    public void whateverMethod() {    }}</code></pre><p>枚举方法的调用方式</p><pre><code>Singleton.INSTANCE.whateverMethod();</code></pre><p>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，不知道是不是1.5加入，所以使用较少</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/singleton-pattern.html</a><br><a href="https://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaoyan001/p/6365064.html</a><br><a href="https://baike.baidu.com/item/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/5946627?fr=aladdin#reference-[2]-1859857-wrap" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/5946627?fr=aladdin#reference-[2]-1859857-wrap</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;学习单例模式(Singleton pattern)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mysql中like何时使用索引</title>
    <link href="blog.virualyz.com/2019/04/04/2019-04-02_22-24-09_mysql%E4%B8%ADlike%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/"/>
    <id>blog.virualyz.com/2019/04/04/2019-04-02_22-24-09_mysql中like何时使用索引/</id>
    <published>2019-04-04T14:00:00.000Z</published>
    <updated>2019-04-04T13:36:36.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>生产环境有个sql查询，我自己查询挺慢的，但是我又看了下表，查询的字段是有索引的，所以我在奇怪，拿出log的日志</p><pre><code>select * from table where a like &apos;%xxx%&apos;</code></pre><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要解决在sql中使用like,不触发索引,探讨怎么使like下使用索引</p><a id="more"></a><h2 id="探讨过程"><a href="#探讨过程" class="headerlink" title="探讨过程"></a>探讨过程</h2><p>当sql中使用like关键字进行查询数据，这个时候所进行like的字段在部分情况下是无法使用到数据的索引的</p><pre><code>select * from table where a like &apos;%xxx%&apos;</code></pre><p><img src="/04/2019-04-02_22-24-09_mysql中like何时使用索引/Snipaste_2019-04-04_20-58-07.jpg" alt="图片"></p><p>这时索引a是存在的，但是在explain后type为all，至此a索引完全没用上</p><p>那既然like ‘%xxx%’不行，我们试一下’%xxx’</p><pre><code>select * from table where a like &apos;xxx%&apos;</code></pre><p><img src="/04/2019-04-02_22-24-09_mysql中like何时使用索引/Snipaste_2019-04-04_21-10-16.jpg" alt="图片"></p><p>这时还是没有使用到了索引a，那我们再换一下，试一下’xxx%’</p><p><img src="/04/2019-04-02_22-24-09_mysql中like何时使用索引/Snipaste_2019-04-04_21-08-10.jpg" alt="图片"></p><p>这时使用到了a的索引</p><p>所以当使用like时，如果想要使用索引通过 like ‘xxx%’，可以使用该字段的索引</p><p>如上所述，如果想要使用索引所使用的方式无法完成我们想要完成的。此时可以通过</p><p>LOCATE（’substr’,str,pos），FIND_IN_SET(str1,str2)</p><p>##总结<br>like 需要使用索引必须是 ‘xxx%’,LOCATE,FIND_IN_SET均可完成like模糊查询，<br>速度上这2个比用 like 稍快了一点。(不过这2个函数都不能使用索引)</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/sinat_41780498/article/details/83024781" target="_blank" rel="noopener">https://blog.csdn.net/sinat_41780498/article/details/83024781</a><br><a href="http://www.cnblogs.com/tommy-huang/p/4483583.html" target="_blank" rel="noopener">http://www.cnblogs.com/tommy-huang/p/4483583.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;生产环境有个sql查询，我自己查询挺慢的，但是我又看了下表，查询的字段是有索引的，所以我在奇怪，拿出log的日志&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from table where a like &amp;apos;%xxx%&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要解决在sql中使用like,不触发索引,探讨怎么使like下使用索引&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="blog.virualyz.com/categories/mysql/"/>
    
    
      <category term="数据库" scheme="blog.virualyz.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(二)抽象工厂模式</title>
    <link href="blog.virualyz.com/2019/03/31/2019-03-31_16-43-12_23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/03/31/2019-03-31_16-43-12_23种设计模式(二)抽象工厂模式/</id>
    <published>2019-03-31T10:00:00.000Z</published>
    <updated>2019-03-31T13:57:09.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>学习抽象工厂模式(Abstract Factory)<br><a id="more"></a></p><h1 id="抽象工厂模式介绍"><a href="#抽象工厂模式介绍" class="headerlink" title="抽象工厂模式介绍"></a>抽象工厂模式介绍</h1><p>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。<br>抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。<br>抽象工厂模式可以向客户端提供一个接口，<br>使客户端在不必指定产品的具体的情况下，<br>创建多个产品族中的产品对象。根据里氏替换原则，任何接受父类型的地方，<br>都应当能够接受子类型。因此，实际上系统所需要的，<br>仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。<br>换言之，也就是这些抽象产品的具体子类的实例。<br>工厂类负责创建抽象产品的具体子类的实例</p><p>当每个抽象产品都有多于一个的具体子类的时候，工厂角色怎么知道实例化哪一个子类呢？比如每个抽象产品 [1]  角色都有两个具体产品。抽象工厂模式提供两个具体工厂角色，分别对应于这两个具体产品角色，每一个具体工厂角色只负责某一个产品角色的实例化。每一个具体工厂类只负责创建抽象产品的某一个具体子类的实例。<br>每一个模式都是针对一定问题的解决方案，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式针对的是多个产品等级结构。</p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>1、抽象工厂</p><p>2、具体工厂</p><p>3、抽象产品</p><p>4、具体产品</p><p>5、产品使用者</p><p>说明：</p><p>具体工厂“继承”抽象工厂；</p><p>具体产品”继承“抽象产品；</p><p>每个具体工厂（如PC工厂）包含若干个子工厂方法（如cpu工厂方法、显卡工厂方法…），子工厂方法负责生产对应的具体子产品，所有具体子产品（cpu、内存、显卡…）组合成一个具体产品（如惠普XXX型号PC）；</p><p>产品使用者使用每个具体工厂生产的具体产品；</p><h1 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h1><p>具体的实例代码：</p><p>1.抽象产品:衣服、裤子</p><p>1、衣服<br>    package com.test.demo;</p><pre><code>/** * * @author test */public interface Clothes {    /**     * 获得名字     */    void printName();}</code></pre><p>2、裤子</p><pre><code>package com.test.demo;/** * * @author test */public interface Pants {    /**     * 获得名字     */void printName();}</code></pre><p>2.具体产品：花花公子衣服、花花公子裤子、七匹狼衣服、七匹狼裤子</p><p>  1、花花公子衣服</p><pre><code>package com.test.demo;/** * * @author test */public class PlayBoyClothes implements Clothes{    private String name;    public PlayBoyClothes(String name) {        this.name = name;        System.out.println(&quot;create a PlayBoyClothes.&quot;);    }    /**     * @return the name     */    public String getName() {        return name;    }    /**     * @param name the name to set     */    public void setName(String name) {        this.name = name;    }    @Override    public void printName() {        System.out.println(this.getClass().getName() + &quot;:&quot; + this.name);    }}</code></pre><p>  2、花花公子裤子</p><pre><code>package com.test.demo;/** * * @author test */public class PlayBoyPants implements Pants{    private String name;    public PlayBoyPants(String name) {        this.name = name;        System.out.println(&quot;create a PlayBoyPants.&quot;);    }    /**     * @return the name     */    public String getName() {        return name;    }    /**     * @param name the name to set     */    public void setName(String name) {        this.name = name;    }    @Override    public void printName() {        System.out.println(this.getClass().getName() + &quot;:&quot; + this.name);    }}</code></pre><p>   3、七匹狼衣服</p><pre><code>package com.test.demo;/** * * @author test */public class SeptwolvesClothes implements Clothes{    private String name;    public SeptwolvesClothes(String name) {        this.name = name;        System.out.println(&quot;create a SeptwolvesClothes.&quot;);    }    /**     * @return the name     */    public String getName() {        return name;    }    /**     * @param name the name to set     */    public void setName(String name) {        this.name = name;    }    @Override    public void printName() {        System.out.println(this.getClass().getName() + &quot;:&quot; + this.name);    }}</code></pre><p>   4、七匹狼裤子<br>    package com.test.demo;</p><pre><code>/** * * @author test */public class SeptwolvesPants implements Pants{    private String name;    public SeptwolvesPants(String name) {        this.name = name;        System.out.println(&quot;create a SeptwolvesPants.&quot;);    }    /**     * @return the name     */    public String getName() {        return name;    }    /**     * @param name the name to set     */    public void setName(String name) {        this.name = name;    }    @Override    public void printName() {        System.out.println(this.getClass().getName() + &quot;:&quot; + this.name);    }}</code></pre><p>3.抽象工厂</p><pre><code>package com.test.demo;/** * * @author test */public interface SuitFactory {    Clothes createClothes(String name);    Pants createPants(String name);}</code></pre><p>4.具体工厂子类</p><p>   1、花花公子工厂</p><pre><code>package com.test.demo;/** * * @author test */public class PlayBoyFactory implements SuitFactory {    @Override    public Clothes createClothes(String name) {        return new PlayBoyClothes(name);    }    @Override    public Pants createPants(String name) {        return new PlayBoyPants(name);    }}</code></pre><p>   2、七匹狼工厂</p><pre><code>package com.test.demo;/** * * @author test */public class SeptwolvesFactory implements SuitFactory {    @Override    public Clothes createClothes(String name) {        return new SeptwolvesClothes(name);    }    @Override    public Pants createPants(String name) {        return new SeptwolvesPants(name);    }}</code></pre><p>最后，使用简单的测试类，来验证下 不同的工厂能够产生不同的产品对象：测试类如下：</p><pre><code>package com.test.demo;/** * * @author test */public class Test {    public static void main(String[] args) {        SuitFactory PlayBoyFactory = new PlayBoyFactory();        SuitFactory SeptwolvesFactory = new SeptwolvesFactory();        Clothes playBoyClothes = PlayBoyFactory.createClothes(&quot;PlayBoy秋冬上装&quot;);        Pants playBoyPants = PlayBoyFactory.createPants(&quot;PlayBoy秋冬裤子&quot;);        Clothes septwolvesClothes = SeptwolvesFactory.createClothes(&quot;Septwolves秋冬上装&quot;);        Pants septwolvesCants = SeptwolvesFactory.createPants(&quot;Septwolves秋冬裤子&quot;);        playBoyClothes.printName();        playBoyPants.printName();        septwolvesClothes.printName();        septwolvesCants.printName();    }}</code></pre><p>打印结果如下：</p><p>create a PlayBoyClothes.<br>create a PlayBoyPants.<br>create a SeptwolvesClothes.<br>create a SeptwolvesPants.<br>com.test.demo.PlayBoyClothes:PlayBoy秋冬上装<br>com.test.demo.PlayBoyPants:PlayBoy秋冬裤子<br>com.test.demo.SeptwolvesClothes:Septwolves秋冬上装<br>com.test.demo.SeptwolvesPants:Septwolves秋冬裤子</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/2361182" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/2361182</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;学习抽象工厂模式(Abstract Factory)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式延伸" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BB%B6%E4%BC%B8/"/>
    
    
      <category term="设计模式延伸" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BB%B6%E4%BC%B8/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式延伸-简单工厂模式</title>
    <link href="blog.virualyz.com/2019/03/31/2019-03-31_17-09-37_23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BB%B6%E4%BC%B8-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/03/31/2019-03-31_17-09-37_23种设计模式延伸-简单工厂模式/</id>
    <published>2019-03-31T08:00:00.000Z</published>
    <updated>2019-03-31T12:31:57.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>学习简单工厂模式<br><a id="more"></a></p><h1 id="简单工厂模式介绍"><a href="#简单工厂模式介绍" class="headerlink" title="简单工厂模式介绍"></a>简单工厂模式介绍</h1><p>简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，<br>但不属于23种GOF设计模式之一。<br>简单工厂模式是工厂模式家族中最简单实用的模式，<br>可以理解为是不同工厂模式的一个特殊实现。</p><p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。<br>该模式中包含的角色及其职责</p><p>工厂（Creator）角色</p><pre><code>简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</code></pre><p>抽象产品（Product）角色</p><pre><code>简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</code></pre><p>具体产品（Concrete Product）角色</p><pre><code>是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。</code></pre><h1 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h1><p>案例的实例代码：</p><p>1.抽象的产品<br>    定义shoe</p><pre><code>package com.test.factory;/** * 产品的抽象接口  鞋子 * @author test * */public interface Shoe {    /**     * 获得名字     */    void getName();}</code></pre><p>2.实际的产品<br>    总共定义两个，ManShoe 和 WomanShoe 分别表示不同的鞋子</p><pre><code>package com.test;import com.test.factory.Shoe;/** * 具体产品类 * ManShoe  男鞋 * @author  test * */public class ManShoe implements Shoe {    @Override    public void getName() {        System.out.println(&quot;男鞋&quot;);    }}package com.test;import com.test.factory.Shoe;/** * 具体产品类 * WomanShoe 女鞋 * @author test * */public class WomanShoe implements Shoe {    @Override    public void getName() {        System.out.println(&quot;女鞋&quot;);    }}</code></pre><p>3.工厂<br>    简单工厂核心类：</p><pre><code>package com.test;import com.test.factory.Shoe;/** * 简单工厂核心类 * @author test * */public class SampleFactory {    public static Shoe makeShoe(String type){        if(&quot;ManShoe&quot;.equals(type)){            Shoe manShoe = new ManShoe();            return manShoe;        }else if(&quot;WomanWShoe&quot;.equals(type)){            Shoe womanShoe = new WomanShoe();            return womanShoe;        }else{            System.out.println(&quot;暂时没有此类鞋&quot;);            return null;        }    }}</code></pre><p>最后，使用简单的测试类，来验证下 工厂能够产生不同的产品对象：测试类如下：</p><pre><code>package com.test;import com.test.factory.Shoe;/** * 简单工厂测试 * @author test * */public class Client {    public static void main(String[] args) {        Shoe manShoe = SampleFactory.makeShoe(&quot;ManShoe&quot;);        System.out.println(null == manShoe);        if(null != manShoe){            manShoe.getName();        }        Shoe wommanShoe = SampleFactory.makeShoe(&quot;WomanShoe&quot;);        System.out.println(null == wommanShoe);        if(null != wommanShoe){            wommanShoe.getName();        }        Shoe neuterShoe = SampleFactory.makeShoe(&quot;NeuterShoe&quot;);        System.out.println(null == neuterShoe);        if(null != neuterShoe){            wommanShoe.getName();        }    }}</code></pre><p>打印结果如下：</p><p>false<br>男鞋<br>false<br>女鞋<br>没有此类鞋<br>true</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。<br>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；<br>这些缺点在工厂方法模式中得到了一定的克服。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>工厂类负责创建的对象比较少；<br>客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；<br>由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/8801727" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/8801727</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;学习简单工厂模式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式延伸" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BB%B6%E4%BC%B8/"/>
    
    
      <category term="设计模式延伸" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BB%B6%E4%BC%B8/"/>
    
  </entry>
  
  <entry>
    <title>mysql中or条件的使用优化避免全表扫描</title>
    <link href="blog.virualyz.com/2019/03/28/2019-03-28_22-39-35-mysql%E4%B8%ADor%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96%E9%81%BF%E5%85%8D%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F/"/>
    <id>blog.virualyz.com/2019/03/28/2019-03-28_22-39-35-mysql中or条件的使用优化避免全表扫描/</id>
    <published>2019-03-28T14:00:00.000Z</published>
    <updated>2019-03-28T15:01:03.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>生产环境有个sql很缓慢,查询了全表,类似</p><pre><code>select * from table where  = 1 or b = 2</code></pre><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要解决在sql中使用or的情况下,尽量避免sql进行全表查询，也就是type 显示all的情况</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p> MySQL在 5.0版本中引入新特性：索引合并优化(Index merge optimization)，当查询中单张表可以使用多个索引时，同时扫描多个索引并将扫描结果进行合并</p><p>该特新主要应用于以下三种场景：</p><p>1、对OR语句求并集，如查询SELECT * FROM TB1 WHERE c1=”xxx” OR c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果合并（union）操作，得到最终结果</p><p>2、对AND语句求交集，如查询SELECT * FROM TB1 WHERE c1=”xxx” AND c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果取交集（intersect）操作，得到最终结果</p><p>3、对AND和OR组合语句求结果</p><p>该新特性可以在一些场景中大幅度提升查询性能，但受限于MySQL糟糕的统计信息，也导致很多场景查询性能极差甚至导致数据库崩溃。</p><p>以SELECT * FROM table WHERE a=”xxx” AND a=””xxx” 为例：</p><p>1、当a列和b列选择性较高时，按照a和b条件进行查询性能较高且返回数据集较小，再对两个数据量较小的数据集求交集的操作成本也较低，最终整个语句查询高效；</p><p>2、当a列或b列选择性较差且统计信息不准时，比如整表数据量2000万，按照b列条件返回1500万数据，按照a列返回1000条数据，此时按照b列条件进行索引扫描+聚集索引查找的操作成本极高(可能是整表扫描的百倍消耗)，对1000条数据和1500万数据求交集的成本也极高，最终导致整条SQL需要消耗大量CPU和IO资源且相应时间超长，而如果值使用a列的索引，查询消耗资源较少且性能较高。</p><p>由于上述的问题，绝大多数的运维团队都会选择关闭该特性来避免执行异常，京东商城也出现过类似案例，严重影响业务正常运行。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在某些情况下，or条件可以避免全表扫描的。<br>1、where 语句里面如果带有or条件, myisam表能用到索引， innodb不行。</p><pre><code>mysql版本5.5.24测试不成功 mysql版本5.5.35innodb测试不成功</code></pre><p>2 .必须所有的or条件都必须是独立索引，独立索引通俗的讲就是自己这一列单独有一个索引</p><ol start="3"><li>用UNION替换OR (适用于索引列)</li></ol><pre><code>通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果. 对索引列使用OR将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低. </code></pre><ol start="4"><li>用in来替换or  </li></ol><pre><code>低效: select…. from location where loc_id = 10 or loc_id = 20 or loc_id = 30 高效 select… from location where loc_in  in (10,20,30);</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/hguisu/article/details/7106159" target="_blank" rel="noopener">https://blog.csdn.net/hguisu/article/details/7106159</a><br><a href="https://blog.csdn.net/fsp88927/article/details/80662422" target="_blank" rel="noopener">https://blog.csdn.net/fsp88927/article/details/80662422</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;生产环境有个sql很缓慢,查询了全表,类似&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from table where  = 1 or b = 2
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要解决在sql中使用or的情况下,尽量避免sql进行全表查询，也就是type 显示all的情况&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="blog.virualyz.com/categories/mysql/"/>
    
    
      <category term="数据库" scheme="blog.virualyz.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>mysql优化神器explain介绍</title>
    <link href="blog.virualyz.com/2019/03/16/2019-03-17_18-06-48_mysql%E4%BC%98%E5%8C%96%E7%A5%9E%E5%99%A8explain/"/>
    <id>blog.virualyz.com/2019/03/16/2019-03-17_18-06-48_mysql优化神器explain/</id>
    <published>2019-03-15T16:00:00.000Z</published>
    <updated>2019-03-18T05:42:28.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>explain是mysql提供的一个优化sql的命令,在5.6以及以后的版本中,<br>除select,如insert,update和delete均可以使用explain查看执行计划，<br>从而知道mysql是如何处理sql语句，分析查询语句或者表结构的性能瓶颈,<br>本次使用的mysql 版本为</p><pre><code>@@version5.6.38</code></pre><p>但是为与5.6之后版本关联起来，所以部分内容可能还会含有其他版本的内容</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>在sql语句前面增加 explain 即可,5.6.x版本显示部分字段需要添加部分关键字</p><pre><code>explain SELECT * FROM TABLE_NAMEexplain extended SELECT * FROM TABLE_NAME</code></pre><a id="more"></a> <h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>1.需要分析的sql</p><p>2.数据库工具或直接连接数据库</p><p>这里我们创建表来查看</p><pre><code>CREATE TABLE `test_table_3` (  `id`   BIGINT(63)  NOT NULL AUTO_INCREMENT,  `ball_name` VARCHAR(125) NOT NULL DEFAULT &apos;&apos;,  `size`  INT(115)              DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `ball_name_index` (`ball_name`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;1&apos;, 100);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;2&apos;, 200);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;3&apos;, 300);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;4&apos;, 400);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;5&apos;, 500);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;6&apos;, 600);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;7&apos;, 700);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;8&apos;, 800);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;9&apos;, 900);INSERT INTO test_table_3 (ball_name, size) VALUES (&apos;10&apos;, 1000);CREATE TABLE `test_table_4` (  `id`           BIGINT(15)  NOT NULL AUTO_INCREMENT,  `ball_id`      BIGINT(15)           DEFAULT NULL,  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,  `productor`    VARCHAR(30)          DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `user_product_detail_index` (`ball_id`, `product_name`, `productor`))  ENGINE = InnoDB  DEFAULT CHARSET = utf8INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (1, &apos;A&apos;, &apos;耐克&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (1, &apos;B&apos;, &apos;李宁&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (1, &apos;A&apos;, &apos;安踏&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (2, &apos;A&apos;, &apos;耐克&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (2, &apos;C&apos;, &apos;李宁&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (3, &apos;D&apos;, &apos;361&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (4, &apos;A&apos;, &apos;耐克&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (6, &apos;A&apos;, &apos;耐克&apos;);INSERT INTO test_table_4 (ball_id, product_name, productor) VALUES (9, &apos;E&apos;, &apos;特步&apos;);</code></pre><h1 id="介绍explain查询出的每项的含义"><a href="#介绍explain查询出的每项的含义" class="headerlink" title="介绍explain查询出的每项的含义"></a>介绍explain查询出的每项的含义</h1><p>   执行sql </p><pre><code>explain select * from test_table_3 where id = 2</code></pre><p>   <img src="/16/2019-03-17_18-06-48_mysql优化神器explain/Snipaste_2019-03-17_17-25-55.jpg" alt="图片"></p><h2 id="列介绍"><a href="#列介绍" class="headerlink" title="列介绍"></a>列介绍</h2><p>各列的含义如下:</p><pre><code>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.select_type: SELECT 查询的类型.table: 查询的是哪个表partitions: 匹配的分区type: join 类型possible_keys: 此次查询中可能选用的索引key: 此次查询中确切使用到的索引.ref: 哪个字段或常数与 key 一起被使用rows: 显示此查询一共扫描了多少行. 这个是一个估计值.filtered: 表示此查询条件所过滤的数据的百分比extra: 额外的信息</code></pre><h2 id="每列数值分析"><a href="#每列数值分析" class="headerlink" title="每列数值分析"></a>每列数值分析</h2><p>   id:由数据库分配的id,无特定的某些数值</p><pre><code>1. ID如果相同，可以认为是一组，从上往下顺序执行2. ID不同,其中ID越大，优先级越高，越早执行3. ID列为null的就表是这是一个结果集，不需要使用它来进行查询。</code></pre><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p> 表示了查询的类型,主要用于区别普通查询，联合查询，子查询等的复杂查询。<br>它的值有:</p><pre><code>SIMPLE, 表示此查询不包含 UNION 查询或子查询PRIMARY, 表示此查询是最外层的查询UNION, 表示此查询是 UNION 的第二或随后的查询DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询UNION RESULT, UNION 的结果SUBQUERY, 子查询中的第一个 SELECTDEPENDENT SUBQUERY(会严重消耗性能): 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.DERIVED：被驱动的SELECT子查询（子查询位于FROM子句）MATERIALIZED：被物化的子查询UNCACHEABLE SUBQUERY：对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作）UNCACHEABLE UNION：UNION操作中，内层的不可被物化的子查询（类似于UNCACHEABLE SUBQUERY）</code></pre><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>本次sql使用的表</p><pre><code>1.如果查询使用了别名,那么这里显示的是别名2.如果不涉及对数据表的操作，那么这显示为null。3.如果显示为尖括号括起来的&lt;derived N&gt;就表示这个是临时表，后边的N就是执行计划中的id,表示结果来自于这个查询产生。4.如果是尖括号括起来的&lt;union M,N&gt;，与&lt;derived N&gt;类似,也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。</code></pre><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>提供了判断查询是否高效的重要依据. 通过此字段, 我们判断此次查询是 全表扫描 还是 索引扫描</p><p>通常来说, 不同的 type 类型的性能关系如下:</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; unique_subquery &gt; index_subquery &gt; range &gt; index_merge &gt; index &gt; ALL</p><p>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><p>除了all之外，其他的type都可以使用到索引，<br>除了index_merge之外，其他的type只可以用到一个索引</p><p>常用的值有:</p><pre><code>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。因为仅有一行，在这行的列值可被优化器认为是常数.onst表很快，因为它们只读取一次！其他数据库也叫做唯一索引扫描        system: 表中只有一条数据. 这个类型是特殊的 const 类型.        表中只有一行数据或者是空表，且只能用于myisam和memory表。        如果是Innodb引擎表，type列在这个情况通常都是all或者indexeq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高出现在要连接多个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref。ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. 不像eq_ref那样要求连接顺序,也没有主键和唯一索引的要求,只要使用相等条件检索时就可能出现。常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现。总之，返回数据不唯一的等值查找就可能出现。   ref可以用于使用=或&lt;=&gt;操作符的带索引的列。fulltext全文索引的优先级很高,若全文索引和普通索引同时存在时,mysql不管代价，优先选择使用全文索引ref_or_null该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。实际用的不多。5.7版本貌似已经废弃了,unique_subquery该类型替换了下面形式的IN子查询的ref：value IN (SELECT primary_key FROM single_table WHERE some_expr)子查询返回不重复值唯一值.unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。index_subquery该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：value IN (SELECT key_column FROM single_table WHERE some_expr)range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个index_merge该联接类型表示使用了索引合并优化方法。表示查询使用了两个以上的索引,最后取交集或者并集,常见and,or的条件使用了不同的索引。官方排序这个在ref_or_null之后，但是实际上由于要读取所有索引，性能可能大部分时间都不如rangeindex: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index通常比ALL快,因为索引文件通常比数据文件小。可以使用索引排序或者分组的查询以及覆盖索引查询。ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。需要避免的类型,效率最低。可以根据查询条件新增或者调整索引。</code></pre><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</p><pre><code>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。</code></pre><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><pre><code>select_type为index_merge时，这里可能出现两个以上的索引。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引,在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</code></pre><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><pre><code>字符串    char(n): n 字节长度    varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.数值类型:    TINYINT: 1字节    SMALLINT: 2字节    MEDIUMINT: 3字节    INT: 4字节    BIGINT: 8字节时间类型    DATE: 3字节    TIMESTAMP: 4字节    DATETIME: 8字节</code></pre><p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>   如果是使用的常数等值查询,这里会显示const<br>   如果是连接查询,被驱动表的执行计划这里会显示驱动表的关联字段<br>   如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>  rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>  这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>   EXplain 中的很多额外的信息会在 Extra 字段显示,包含有关MySQL如何解析查询的其他信息。<br>   此字段能够给出让我们深入理解执行计划进一步的细节信息，比如是否使用ICP，MRR等<br>   常见的有以下几种内容:</p><pre><code>Using filesort排序时无法使用到索引，常见于order by和group by语句中,此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行。出现这个,查询就需要优化了,MYSQL需要进行额外的步骤来对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行.这并不代表着真的使用了文件排序！当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.Using index查询无需回表，直接通过索引就可以获取查询的数据,不用扫描表数据文件,即覆盖索引！Using temporary表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。发生这种情况一般都是需要进行优化的-般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.Using where表示查询返回的记录并不是所有的都满足查询条件,需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层,不符合检查条件和限制条件的数据，直接不读取,这样就大大减少了存储引擎扫描的记录数量。extra列显示using index conditionUsing sort_union(...)/Using union(...)/Using intersect(...)using intersect：表示使用and多个索引查询时,从处理结果获取交集using union：表示使用or多个索引查询时,从处理结果获取并集using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时,先查询主键,然后进行排序合并后,才能读取记录并返回。using intersect：表示使用and多个索引查询时,从处理结果获取交集using union：表示使用or多个索引查询时,从处理结果获取并集using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时,先查询主键,然后进行排序合并后,才能读取记录并返回。Using index for group-by表明可以在索引中找到分组所需的所有数据，不需要查询实际的表。 注意,这里是非主键！using join buffer（block nested loop），using join buffer（batched key accss）5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。firstmatch(tb_name)5.6.x开始引入的优化子查询的新特性之一,常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个loosescan(m..n)5.6.x之后引入的优化子查询的新特性之一,在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个impossible where:where子句的值总是false，不能用来获取任何元组select tables optimized away：在没有group by子句的情况下，基于索引优化Min、max操作或者对于MyISAM存储引擎优化count（*），不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</code></pre><p>###<br>版本5.7以前，该项是解释分区显示的选项，5.7以后成为了默认选项。该列显示的为分区表命中的分区情况。非分区表该字段为空（null）。</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><pre><code>使用explain extended时会出现这个列。5.7之后的版本默认就有这个字段。不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例,注意是百分比，不是具体记录数。</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/bingoxubin/article/details/78720976" target="_blank" rel="noopener">https://blog.csdn.net/bingoxubin/article/details/78720976</a></p><p><a href="https://blog.csdn.net/bingoxubin/article/details/78720976" target="_blank" rel="noopener">https://blog.csdn.net/bingoxubin/article/details/78720976</a></p><p><a href="https://blog.csdn.net/itfootball/article/details/44876517" target="_blank" rel="noopener">关闭重启jenkins</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;explain是mysql提供的一个优化sql的命令,在5.6以及以后的版本中,&lt;br&gt;除select,如insert,update和delete均可以使用explain查看执行计划，&lt;br&gt;从而知道mysql是如何处理sql语句，分析查询语句或者表结构的性能瓶颈,&lt;br&gt;本次使用的mysql 版本为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@@version
5.6.38
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是为与5.6之后版本关联起来，所以部分内容可能还会含有其他版本的内容&lt;/p&gt;
&lt;h1 id=&quot;使用方式&quot;&gt;&lt;a href=&quot;#使用方式&quot; class=&quot;headerlink&quot; title=&quot;使用方式&quot;&gt;&lt;/a&gt;使用方式&lt;/h1&gt;&lt;p&gt;在sql语句前面增加 explain 即可,5.6.x版本显示部分字段需要添加部分关键字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;explain SELECT * FROM TABLE_NAME

explain extended SELECT * FROM TABLE_NAME
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="mysql" scheme="blog.virualyz.com/categories/mysql/"/>
    
    
      <category term="explain" scheme="blog.virualyz.com/tags/explain/"/>
    
  </entry>
  
  <entry>
    <title>mac版DBeaver查询出来的日期错误</title>
    <link href="blog.virualyz.com/2019/03/10/2019%E5%B9%B403%E6%9C%8810%E6%97%A515:26:21_mac%E7%89%88DBeaver%E6%9F%A5%E8%AF%A2%E5%87%BA%E6%9D%A5%E7%9A%84%E6%97%A5%E6%9C%9F%E9%94%99%E8%AF%AF/"/>
    <id>blog.virualyz.com/2019/03/10/2019年03月10日15:26:21_mac版DBeaver查询出来的日期错误/</id>
    <published>2019-03-10T04:00:00.000Z</published>
    <updated>2019-03-10T07:50:51.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>通过DBeaver查询出来的日期发现比正常时间多,明明是今天的日期，但是sql查询数据库出来的数据确是明天<br>因此对于使用有很大的影响</p><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要解决mac中DBeaver中查询数据错误的问题解决</p> <a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p> 1:在数据库连接上点击出图示(一般为右键)</p><p> <img src="/10/2019年03月10日15:26:21_mac版DBeaver查询出来的日期错误/1552199583202.jpg" alt="图片"></p><p> 2:在其中修改</p><p> <img src="/10/2019年03月10日15:26:21_mac版DBeaver查询出来的日期错误/WX20190310-144340@2x.png" alt="图片"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p> [<a href="https://blog.csdn.net/qq_40763761/article/details/79729147]" target="_blank" rel="noopener">https://blog.csdn.net/qq_40763761/article/details/79729147]</a>(<a href="https://blog.csdn.net/qq_40763761/article/details/79729147" target="_blank" rel="noopener">https://blog.csdn.net/qq_40763761/article/details/79729147</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;通过DBeaver查询出来的日期发现比正常时间多,明明是今天的日期，但是sql查询数据库出来的数据确是明天&lt;br&gt;因此对于使用有很大的影响&lt;/p&gt;
&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要解决mac中DBeaver中查询数据错误的问题解决&lt;/p&gt;
    
    </summary>
    
      <category term="MAC" scheme="blog.virualyz.com/categories/MAC/"/>
    
    
      <category term="DBeaver" scheme="blog.virualyz.com/tags/DBeaver/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式(一)工厂方法模式</title>
    <link href="blog.virualyz.com/2019/03/03/2019%E5%B9%B403%E6%9C%8803%E6%97%A522:05:02-23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>blog.virualyz.com/2019/03/03/2019年03月03日22:05:02-23种设计模式(一)工厂方法模式/</id>
    <published>2019-03-03T14:05:02.000Z</published>
    <updated>2019-03-03T14:24:58.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>学习工厂模式<br><a id="more"></a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>工厂方法模式：也叫工厂模式，属于类创建型模式，工厂父类（接口）负责定义产品对象的公共接口，而子类工厂则负责创建具体的产品对象。</p><p>目的：是为了把产品的实例化操作延迟到子类工厂中完成，通过工厂子类来决定究竟应该实例化哪一个产品具体对象。</p><p>工厂方法模式包含四个部分：</p><p>1.抽象产品：产品对象同一的基类，或者是同一的接口。</p><p>2.具体的产品：各个不同的实例对象类</p><p>3.抽象工厂：所有的子类工厂类的基类，或是同一的接口</p><p>4.具体的工厂子类：负责每个不同的产品对象的实际创建</p><h1 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h1><p>具体的实例代码：</p><p>1.抽象的产品类：定义car  交通工具类下：</p><pre><code>package factory.simple;/** * 抽象产品角色 交通工具接口 *  * @author lilin *  */public interface Car {    /**     * 上班函数     */    void gotowork();}</code></pre><p>2.定义实际的产品类，总共定义两个，bike 和bus 分别表示不同的交通工具类</p><pre><code>package factory.simple;/** * 具体产品角色，自行车 *  * @author lilin *  */public class Bike implements Car {    @Override    public void gotowork() {        System.out.println(&quot;骑自行车去上班！&quot;);    }}package factory.simple;/** * @author lilin *  */public class Bus implements Car {    @Override    public void gotowork() {        System.out.println(&quot;坐公交车去上班！&quot;);    }}</code></pre><p>3.抽象的工厂接口定义如下：</p><pre><code>/** *  */package factory.factory;import factory.simple.Car;/** * @author lilin *  */public interface ICarFactory {    /**     * 获取交通工具     *      * @return     */    Car getCar();}</code></pre><p>4.具体的工厂子类，分别为每个具体的产品类创建不同的工厂子类：</p><pre><code>/** *  */package factory.factory;import factory.simple.Bike;import factory.simple.Car;/** * @author lilin *  */public class BikeFactory implements ICarFactory {    @Override    public Car getCar() {        return new Bike();    }}/** *  */package factory.factory;import factory.simple.Bus;import factory.simple.Car;/** * @author lilin *  */public class BusFactory implements ICarFactory {    @Override    public Car getCar() {        return new Bus();    }}</code></pre><p>最后，使用简单的测试类，来验证下 不同的工厂能够产生不同的产品对象：测试类如下：</p><pre><code>/** *  */package factory.factory;import org.testng.annotations.Test;import factory.simple.Car;/** * @author lilin *  */public class TestFactory {    @Test    public void test() {        ICarFactory factory = null;        // bike        factory = new BikeFactory();        Car bike = factory.getCar();        bike.gotowork();        // bus        factory = new BusFactory();        Car bus = factory.getCar();        bus.gotowork();    }}</code></pre><p>打印结果如下：</p><p>骑自行车去上班！<br>坐公交车去上班！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工厂模式，可以理解为：有了很多个工厂方法，自己需要哪一个产品，就调用当前产品的工厂方法，获取相应的具体实例。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/lilin0719/p/5309397.html" target="_blank" rel="noopener">https://www.cnblogs.com/lilin0719/p/5309397.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt;学习工厂模式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mac端口占用问题</title>
    <link href="blog.virualyz.com/2019/02/28/2019%E5%B9%B402%E6%9C%8828%E6%97%A521:54:55-mac%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>blog.virualyz.com/2019/02/28/2019年02月28日21:54:55-mac端口占用问题/</id>
    <published>2019-02-28T13:56:04.000Z</published>
    <updated>2019-03-29T06:46:46.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>第一次使用mac,关闭idea时忘记关闭tomcat,这时再次启动tomcat会有提示:</p><pre><code>错误: 代理抛出异常错误: java.rmi.server.ExportException: Port already in use: 1099; nested exception is: java.net.BindException: Address already in use: JVM_Bind</code></pre><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要解决mac中端口占用问题</p><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>端口xxxx被占用了</p><p>1)打开终端输入:</p><p>2)lsof -i tcp:占用端口;</p><p>找到被占用的数字，我的是<em>**</em>;</p><pre><code>lsof -i tcp:1099;</code></pre><p>3)kill PID;</p><pre><code>kill ****;  </code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_40763761/article/details/79729147" target="_blank" rel="noopener">https://blog.csdn.net/qq_40763761/article/details/79729147</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;第一次使用mac,关闭idea时忘记关闭tomcat,这时再次启动tomcat会有提示:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;错误: 代理抛出异常错误: java.rmi.server.ExportException: Port already in use: 1099; nested exception is: 

java.net.BindException: Address already in use: JVM_Bind
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要解决mac中端口占用问题&lt;/p&gt;
    
    </summary>
    
      <category term="system" scheme="blog.virualyz.com/categories/system/"/>
    
    
      <category term="system" scheme="blog.virualyz.com/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>node使用过程中碰见的问题</title>
    <link href="blog.virualyz.com/2019/02/28/2019%E5%B9%B402%E6%9C%8828%E6%97%A521:37:38-node%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%A2%B0%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>blog.virualyz.com/2019/02/28/2019年02月28日21:37:38-node使用过程中碰见的问题/</id>
    <published>2019-02-28T13:39:02.000Z</published>
    <updated>2019-02-28T13:46:07.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>在使用过程中总会碰见一些hexo的问题,这些问题都是一些微小并且繁杂的问题，记录下来希望对其他朋友有所帮助</p><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要记录本人在使用hexo中碰见的有关hexo的问题</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="在使用新的next主题重新创建静态文件之后-部分文件顺序错乱"><a href="#在使用新的next主题重新创建静态文件之后-部分文件顺序错乱" class="headerlink" title="在使用新的next主题重新创建静态文件之后,部分文件顺序错乱"></a>在使用新的next主题重新创建静态文件之后,部分文件顺序错乱</h3><pre><code>date: 2015-01-19 00:34:14</code></pre><p>就是在文章的 md 文档前面加 date: ，这个时间的格式可以在你 blog 目录下的_config.yml 中通过 date_format: YYYY-MM-DD HH:mm:ss 来指定。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[tps://<a href="http://www.jianshu.com/p/04d31f6c22bd]" target="_blank" rel="noopener">www.jianshu.com/p/04d31f6c22bd]</a>(<a href="https://www.v2ex.com/t/231549）" target="_blank" rel="noopener">https://www.v2ex.com/t/231549）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;在使用过程中总会碰见一些hexo的问题,这些问题都是一些微小并且繁杂的问题，记录下来希望对其他朋友有所帮助&lt;/p&gt;
&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要记录本人在使用hexo中碰见的有关hexo的问题&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="blog.virualyz.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="blog.virualyz.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>mac使用nvm管理node以及npm</title>
    <link href="blog.virualyz.com/2019/02/28/2019%E5%B9%B402%E6%9C%8828%E6%97%A521:30:37-nvm%E7%AE%A1%E7%90%86node/"/>
    <id>blog.virualyz.com/2019/02/28/2019年02月28日21:30:37-nvm管理node/</id>
    <published>2019-02-28T00:00:00.000Z</published>
    <updated>2019-02-28T13:32:18.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因-cause"><a href="#原因-cause" class="headerlink" title="原因(cause)"></a>原因(cause)</h1><p>好久没动笔，我想启动我的hexo，并写上一些分享，我通过下载gitlab上的私有仓库，然后转入github中，下载下来并安装好node.js之后，我执行<br>    npm install -g hexo-cli<br>希望可以启动我的hexo，但此时却抛出个异常</p><pre><code>The operation was rejected by your operating system</code></pre><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p> 本文主要解决mac中node的各个版本会有差异，新旧系统兼容，第三方组件与node版本导致的全局版本混乱等等，所以通过nvm管理起来,网上查询了下资料,有人说可以不卸载直接安装,为了保险起见，我先卸载了，对于不卸载的朋友，请斟酌后再试。</p><a id="more"></a><h2 id="nvm介绍"><a href="#nvm介绍" class="headerlink" title="nvm介绍"></a>nvm介绍</h2><p>nvm是node版本管理工具，主要特点：</p><p>1.可安装多版本的node。</p><p>2.灵活切换当前的node版本。</p><p>3.以沙箱方式全局安装第三方组件到对应版本的node中。</p><p>4.通过.vnmrc文件，方便灵活地指定各应用系统所需的node版本进行运行。</p><p>直接支持linux，OS系统。windows系统需要使用nvm-windows：<br><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a></p><p>通过nvm管理node，如果之前通过安装包安装推荐删除，如果不删除也不影响安装，只有在别人使用你的电脑的另外账户时会有问题。具体的注意事项可以参考：<br><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">https://github.com/creationix/nvm</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="卸载之前的node-js"><a href="#卸载之前的node-js" class="headerlink" title="卸载之前的node.js"></a>卸载之前的node.js</h3><p>如果通过<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">node</a>下载的安装包进行安装，在终端输入以下命令：</p><pre><code>sudo rm -rf                 /usr/local/{bin/{node,npm},lib/node_modules/npm,lib/node,share/man/*/node.*}</code></pre><p>如果是从brew安装的, 运行brew uninstall node</p><p>如果不是则可以直接删除文件夹</p><p>sudo rm /usr/local/bin/npm<br>sudo rm/usr/local/share/man/man1/node.1<br>sudo rm /usr/local/lib/dtrace/node.d<br>sudo rm -rf ~/.npm<br>sudo rm -rf ~/.node-gyp<br>sudo rm /opt/local/bin/node<br>sudo rm /opt/local/include/node<br>sudo rm -rf /opt/local/lib/node_modules</p><h4 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h4><p>安装nvm可以通过两个命令</p><pre><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</code></pre><p>或者</p><pre><code>wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</code></pre><h4 id="查看安装"><a href="#查看安装" class="headerlink" title="查看安装"></a>查看安装</h4><p>安装完毕后输入nvm，当有一段输出并没有明显的报错时，代表安装成功。<br>博主通过命令安装后，自动在 .bash_profile 文件内添加了</p><pre><code>export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot; $NVM_DIR/nvm.sh&quot;</code></pre><p>如果你没有添加，可以手动添加<br>然后 source 一下 .bash_profile</p><pre><code>source .bash_profile</code></pre><h4 id="安装版本"><a href="#安装版本" class="headerlink" title="安装版本"></a>安装版本</h4><pre><code>nvm install stable # 安装最新稳定版 nodenvm install 10.15.1 # 安装 10.15.1 版本</code></pre><p>查看nvm版本：打开新的终端，用nvm current查看当前版本显示</p><p>删除指定版本 node：nvm uninstall v10.15.1</p><p>使用指定版本 node：nvm use v10.15.1</p><p>切换到最新版：<br>nvm use node</p><pre><code>我们给 10.15.1 这个版本号起了一个名字叫做 my-versionnvm alias my-version 10.15.1</code></pre><p>然后我们可以运行：</p><pre><code>nvm use my-version</code></pre><p>下面这个命令可以取消别名：</p><pre><code>nvm unalias my-version</code></pre><p>另外，你还可以设置 default 这个特殊别名：</p><pre><code>nvm alias default node</code></pre><p>列出已安装实例</p><pre><code>nvm ls</code></pre><h2 id="碰到的问题以及解决方法"><a href="#碰到的问题以及解决方法" class="headerlink" title="碰到的问题以及解决方法"></a>碰到的问题以及解决方法</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">https://github.com/creationix/nvm</a><br><a href="https://blog.csdn.net/hahahhahahahha123456/article/details/85220526" target="_blank" rel="noopener">https://blog.csdn.net/hahahhahahahha123456/article/details/85220526</a><br><a href="https://www.jianshu.com/p/04d31f6c22bd" target="_blank" rel="noopener">https://www.jianshu.com/p/04d31f6c22bd</a><br><a href="https://www.jianshu.com/p/04d31f6c22bd" target="_blank" rel="noopener">https://www.jianshu.com/p/04d31f6c22bd</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;原因-cause&quot;&gt;&lt;a href=&quot;#原因-cause&quot; class=&quot;headerlink&quot; title=&quot;原因(cause)&quot;&gt;&lt;/a&gt;原因(cause)&lt;/h1&gt;&lt;p&gt;好久没动笔，我想启动我的hexo，并写上一些分享，我通过下载gitlab上的私有仓库，然后转入github中，下载下来并安装好node.js之后，我执行&lt;br&gt;    npm install -g hexo-cli&lt;br&gt;希望可以启动我的hexo，但此时却抛出个异常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The operation was rejected by your operating system
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;本文介绍&quot;&gt;&lt;a href=&quot;#本文介绍&quot; class=&quot;headerlink&quot; title=&quot;本文介绍&quot;&gt;&lt;/a&gt;本文介绍&lt;/h1&gt;&lt;p&gt; 本文主要解决mac中node的各个版本会有差异，新旧系统兼容，第三方组件与node版本导致的全局版本混乱等等，所以通过nvm管理起来,网上查询了下资料,有人说可以不卸载直接安装,为了保险起见，我先卸载了，对于不卸载的朋友，请斟酌后再试。&lt;/p&gt;
    
    </summary>
    
      <category term="mvn" scheme="blog.virualyz.com/categories/mvn/"/>
    
    
      <category term="mvn" scheme="blog.virualyz.com/tags/mvn/"/>
    
  </entry>
  
  <entry>
    <title>mac中git创建秘钥</title>
    <link href="blog.virualyz.com/2018/10/06/201810061650-git%E5%88%9B%E5%BB%BA%E7%A7%98%E9%92%A5/"/>
    <id>blog.virualyz.com/2018/10/06/201810061650-git创建秘钥/</id>
    <published>2018-10-06T08:50:03.000Z</published>
    <updated>2019-03-30T13:40:05.641Z</updated>
    
    <content type="html"><![CDATA[<p>#背景<br>从git上通过idea工具clone了一个项目，但是在提交代码的时候发现提示错误，错误代码大致如下</p><pre><code>git@github.com: Permission denied (publickey)</code></pre><p>找了下原因发现是没有公钥导致的，之前安装git并clone下代码之后没有进行提交，觉得没问题了，发现还是省不得操作啊。</p><p>#解决方法</p><p>通过生成一个公钥配置到git账号里面的ssh那个菜单就ok了</p><a id="more"></a><p>#具体步骤</p><p>1.通过ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>进行测试查看有没有公钥，如果没提示就会出现和我一样的情况</p><p>2.通过命令直接生成公钥</p><pre><code>ssh-keygen -t rsa -b 2048 -C “youreamil@email.com” </code></pre><p>3.执行完之后会出，此步是让你输入自定义的文件名，这里不用管他，默认就好，直接回车进行下一步骤</p><pre><code>Generating public/private rsa key pair. Enter file in which to save the key (/home/xxx/.ssh/id_rsa):</code></pre><p>4.然后会出现如下提示，这步是让你输入一个密码，密码会在提交代码使用(这里除了下面一步，我提交代码时没使用这个密码)，不想设置就直接回车(这步我没有尝试)，如果不能默认<br>那就输入一个然后记住吧。与git密码相同好记忆</p><pre><code>Enter passphrase (empty for no passphrase): Enter same passphrase again: </code></pre><p>5.然后就创建成功了你会看到提示，还有其他一些输出，这里就不写了</p><pre><code>Your identification has been saved in /home/xxx/.ssh/id_rsa. Your public key has been saved in /home/xxx/.ssh/id_rsa.pub. </code></pre><p>6.在成功后把秘钥交给ssh-agent管理</p><pre><code>ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序。ssh-agent是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。</code></pre><p>   先确认ssh-agent处于启用状态： </p><pre><code>eval “$(ssh-agent -s)”</code></pre><p>   输出类似于：</p><pre><code>Agent pid xxxxx</code></pre><p>   然后将SSH key添加到ssh-agent：</p><pre><code>ssh-add ~/.ssh/id_rsa</code></pre><p>   这时又会要你输入上面定义的密码：</p><pre><code>Enter passphrase for /home/xxx/.ssh/id_rsa: </code></pre><p>   输入，回车</p><p>7.打开秘钥所在文件/.ssh,找到默认文件id_rsa.pub</p><pre><code>open ～/.ssh  </code></pre><p>8.把文件内容复制，并添加到你邮件注册的git中，具体路径 git登陆-&gt;settings-&gt;ssh and GPG keys-&gt;new ssh key -&gt; title 随便输入，自己认识就好，key 填写之前生成的公钥-&gt;保存</p><p>9.完毕</p><p>#碰到的问题以及解决方法</p><p>1.mac中直接访达当爱你用户文件找不到/.ssh,通过命令行打开的<br>2.提交代码出现提示，找了下是host没有地址xxx所致，加进去就好了(这个错误在我这里偶尔出现)</p><pre><code>Warning: Permanently added the RSA host key for IP address &apos;xxxxxxxx&apos; to the list of known hosts.</code></pre><p>   解决：</p><pre><code>vim /etc/hosts</code></pre><p>   添加一行：xxx.xxx.xxx.xxx　　github.com</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#背景&lt;br&gt;从git上通过idea工具clone了一个项目，但是在提交代码的时候发现提示错误，错误代码大致如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git@github.com: Permission denied (publickey)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;找了下原因发现是没有公钥导致的，之前安装git并clone下代码之后没有进行提交，觉得没问题了，发现还是省不得操作啊。&lt;/p&gt;
&lt;p&gt;#解决方法&lt;/p&gt;
&lt;p&gt;通过生成一个公钥配置到git账号里面的ssh那个菜单就ok了&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="blog.virualyz.com/categories/git/"/>
    
    
      <category term="git" scheme="blog.virualyz.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>centOS7安装docker</title>
    <link href="blog.virualyz.com/2018/09/24/201809241939-centOS7%E5%AE%89%E8%A3%85docker/"/>
    <id>blog.virualyz.com/2018/09/24/201809241939-centOS7安装docker/</id>
    <published>2018-09-24T11:40:31.000Z</published>
    <updated>2019-02-24T07:47:44.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p><p>一个完整的Docker有以下几个部分组成：</p><ul><li>dockerClient客户端</li><li>Docker Daemon守护进程</li><li>Docker Image镜像</li><li>DockerContainer容器</li></ul><p>另:docker分为社区版CE和企业版EE。<br>社区版是免费提供给个人开发者和小型团体使用的。<br>企业版会提供额外的收费服务，比如插件等。<br>社区版按照stable和edge两种方式发布，每个季度更新stable版本，比如3月6月；每个月份更新edge版本，如1月，2月</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>1.确认当前系统支持安装(我这里用centOS，Docker 要求 CentOS 系统的内核版本高于 3.10 )<br>2.查看是否已经安装，如果是你已经安装，可以自行确认下可否使用，也可以移除已安装<br>3.选择docker版本并安装其他支持<br>4.验证</p><a id="more"></a> <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>1.yum源:<a href="https://download.docker.com/linux/centos/docker-ce.repo(也可以选择阿里源)" target="_blank" rel="noopener">https://download.docker.com/linux/centos/docker-ce.repo(也可以选择阿里源)</a></p><p>2.想要安装的docker版本</p><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><p>1.查看系统信息</p><pre><code>uname -r</code></pre><p>2.用root账户操作</p><pre><code>sudo su</code></pre><p>3.安装需要的软件包</p><pre><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>4.设置yum源</p><pre><code>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p>5.可以查看仓库中所有docker版本，并选择版本安装</p><pre><code>yum list docker-ce --showduplicates | sort -r</code></pre><p>   <img src="/24/201809241939-centOS7安装docker/docker-ce版本.png" alt="docker-ce版本"></p><p>6.安装docker</p><pre><code>yum install docker-ce-17.12.0.ce</code></pre><p>7.验证安装是否成功</p><pre><code>docker version</code></pre><p>8.增加开机启动</p><pre><code>systemctl start dockersystemctl enable docker</code></pre><p>   查看</p><pre><code>systemctl status docker.service</code></pre><p>   <img src="/24/201809241939-centOS7安装docker/docker开机启动.png" alt="docker开机启动"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://baike.baidu.com/item/Docker/13344470?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/Docker/13344470?fr=aladdin</a><br><a href="https://www.cnblogs.com/yufeng218/p/8370670.html" target="_blank" rel="noopener">https://www.cnblogs.com/yufeng218/p/8370670.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;
&lt;p&gt;一个完整的Docker有以下几个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dockerClient客户端&lt;/li&gt;
&lt;li&gt;Docker Daemon守护进程&lt;/li&gt;
&lt;li&gt;Docker Image镜像&lt;/li&gt;
&lt;li&gt;DockerContainer容器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另:docker分为社区版CE和企业版EE。&lt;br&gt;社区版是免费提供给个人开发者和小型团体使用的。&lt;br&gt;企业版会提供额外的收费服务，比如插件等。&lt;br&gt;社区版按照stable和edge两种方式发布，每个季度更新stable版本，比如3月6月；每个月份更新edge版本，如1月，2月&lt;/p&gt;
&lt;h2 id=&quot;大致流程&quot;&gt;&lt;a href=&quot;#大致流程&quot; class=&quot;headerlink&quot; title=&quot;大致流程&quot;&gt;&lt;/a&gt;大致流程&lt;/h2&gt;&lt;p&gt;1.确认当前系统支持安装(我这里用centOS，Docker 要求 CentOS 系统的内核版本高于 3.10 )&lt;br&gt;2.查看是否已经安装，如果是你已经安装，可以自行确认下可否使用，也可以移除已安装&lt;br&gt;3.选择docker版本并安装其他支持&lt;br&gt;4.验证&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>idea创建maven项目--helloWord</title>
    <link href="blog.virualyz.com/2018/09/09/201809091735-idea%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE-helloWord/"/>
    <id>blog.virualyz.com/2018/09/09/201809091735-idea创建maven项目-helloWord/</id>
    <published>2018-09-09T09:36:48.000Z</published>
    <updated>2019-02-24T07:47:44.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。<br>Maven 是一个构建项目十分方便的工具，并且提供许多项目管理的高级功能</p><h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>1.idea</p><p>2.maven（此项可以省略）</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>1.打开idea，在选项卡中选择file-&gt;new-&gt;Project,选择并填写相关信息，确认保存</p><p>2.配置tomcat启动<br><a id="more"></a> </p><h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><p>1.打开idea，在选项卡中选择file-&gt;new-&gt;Project</p><p>2.选择maven,选中create from archetype,在列表中找到图示选项,next<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea创建maven项目选项.png" alt="idea创建maven项目选项"></p><p>3.输入groupId,artifactId<br>GroupID实际对应JAVA的包的结构，是main目录里java的目录结构。 ArtifactID就是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea创建maven项目填写.png" alt="idea创建maven项目填写"></p><p>4.这步可以直接next，这时使用的maven版本就是idea自带的，如果不想使用，可以选择，也可以自定义setting文件路径<br>，以及本地的仓库路径<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea创建maven项目选择版本.png" alt="idea创建maven项目选择版本"></p><p>5.然后就是项目名以及项目路径，可以不改，直接next<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea创建maven项目项目名以及路径.png" alt="idea创建maven项目项目名以及路径"></p><p>项目创建完，我们来尝试启动它看看他的效果</p><p>6.然后进入配置，一种通过选项卡点击run-&gt;Edit Configurations,另一种选择<br>idea右上角的图示位置点击，然后选择Edit Configurations<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea配置tomcat启动EditConfigurations.png" alt="idea配置tomcat启动EditConfigurations"></p><p>7.在Edit Configurations按照图示顺序选择<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea配置tomcat启动.png" alt="idea配置tomcat启动"></p><p>8.选择Artifact<br>Artifact 是maven中的一个概念，表示某个module要如何打包。例如war exploded、war、jar、ear等等这种打包形式；<br>一个module有了 Artifacts 就可以部署到应用服务器中了！</p><p>至于带不带的区别，explode 在这里你可以理解为展开，不压缩的意思。也就是war、jar等产出物没压缩前的目录结构。<br>建议在开发的时候使用这种模式，便于修改了文件的效果立刻显现出来。<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea配置tomcat启动选择Artifact.png" alt="idea配置tomcat启动选择Artifact"><br><img src="/09/201809091735-idea创建maven项目-helloWord/idea配置tomcat启动选择Artifact文件.png" alt="idea配置tomcat启动选择Artifact文件"></p><p>9.最后启动你的项目，你就会看到这样的效果啦<br><img src="/09/201809091735-idea创建maven项目-helloWord/idea配置tomcat启动成功页面.png" alt="idea配置tomcat启动成功页面"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_27093465/article/details/76091287" target="_blank" rel="noopener">https://blog.csdn.net/qq_27093465/article/details/76091287</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。&lt;br&gt;Maven 是一个构建项目十分方便的工具，并且提供许多项目管理的高级功能&lt;/p&gt;
&lt;h1 id=&quot;执行&quot;&gt;&lt;a href=&quot;#执行&quot; class=&quot;headerlink&quot; title=&quot;执行&quot;&gt;&lt;/a&gt;执行&lt;/h1&gt;&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;1.idea&lt;/p&gt;
&lt;p&gt;2.maven（此项可以省略）&lt;/p&gt;
&lt;h2 id=&quot;大致流程&quot;&gt;&lt;a href=&quot;#大致流程&quot; class=&quot;headerlink&quot; title=&quot;大致流程&quot;&gt;&lt;/a&gt;大致流程&lt;/h2&gt;&lt;p&gt;1.打开idea，在选项卡中选择file-&amp;gt;new-&amp;gt;Project,选择并填写相关信息，确认保存&lt;/p&gt;
&lt;p&gt;2.配置tomcat启动&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="maven" scheme="blog.virualyz.com/categories/maven/"/>
    
    
      <category term="maven" scheme="blog.virualyz.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>jenkins在windows下的自动集成</title>
    <link href="blog.virualyz.com/2018/09/07/201809091716-jenkins%E5%9C%A8windows%E4%B8%8B%E7%9A%84%E8%87%AA%E5%8A%A8%E9%9B%86%E6%88%90/"/>
    <id>blog.virualyz.com/2018/09/07/201809091716-jenkins在windows下的自动集成/</id>
    <published>2018-09-06T16:00:00.000Z</published>
    <updated>2019-02-24T07:47:44.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>jenkins优秀的自动集成解决繁琐的项目部署问题，对于提高开发效率有显著的帮助</p><h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>1.需要自动集成的项目test（博主这里创建了一个简单的maven项目）</p><p>2.tomcat配置</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>1.创建或准备一个项目（博主这里名为test的maven项目）</p><p>2.启动的jenkins与安装的插件</p><p>3.tomcat的manager用户配置信息（博主这里admin）</p><a id="more"></a> <h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><p>1.准备自动集成的项目，如果你自己手上有项目，这步可以略过，不会影响下面。<br>如果您没有，可以像我一样创建一个项目<a href="http://focusvirtual.club/2018/09/09/201809091735-idea%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE-helloWord/" target="_blank" rel="noopener">idea创建maven项目-helloWord</a>,<br>最终您会有个项目<br><img src="/07/201809091716-jenkins在windows下的自动集成/jenkins集成项目.png" alt="jenkins集成项目"></p><p>2.配置tomcat用户访问权限<br>到tomcat的安装目录下的conf目录下找 tomcat-users.xml文件，将下面的代码copy到<tomcat-users>标签内，用户名密码可以自己设置</tomcat-users></p><pre><code>&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;role rolename=&quot;manager-jmx&quot;/&gt;&lt;role rolename=&quot;manager-status&quot;/&gt;&lt;user password=&quot;admin&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status&quot; username=&quot;admin&quot;/&gt;</code></pre><p>然后启动tomcat，可以到conf同级的bin目录点击startup.bat运行</p><p>注意:这里如果你的tomcat与jenkins的端口号有冲突的话,修改jenkins、tomcat的端口号任一即可</p><p>3.登录jenkins,并在系统管理-&gt;插件管理-&gt;已安装中查找插件–Deploy to container Plugin，<br>如果能找到代表您已经安装，如果没有请在可选插件中查找并安装<br><img src="/07/201809091716-jenkins在windows下的自动集成/jenkins插件_Deploy-to-container-Plugin.png" alt="jenkins插件_Deploy-to-container-Plugin"></p><p>4.在jenkins主界面点击新建任务，选择如图,然后输入名称这里起名test，点击下方的确定<br><img src="/07/201809091716-jenkins在windows下的自动集成/jenkins创建任务.png" alt="jenkins创建任务"></p><p><img src="/07/201809091716-jenkins在windows下的自动集成/jenkins构建自由风格软件.png" alt="jenkins构建自由风格软件"></p><p>5.然后进入配置页面，描述可以不填写，选择丢弃旧的构建，剩下保持构建天数以及保持构建的最大个数均可按照自己的喜好填写</p><p>保持构建的天数 就是根据你所填写的天数来保存构建记录</p><p>保持构建的最大个数  就是保存填写条数的构建记录<br>jenkins创建任务配置1.png<br><img src="/07/201809091716-jenkins在windows下的自动集成/jenkins创建任务配置1.png" alt="jenkins创建任务配置1"></p><p>6.在源码管理中，选择无,其次在最开始的配置中，打开高级，可以看到如下更多的设置，其中-&gt;使用自定义的工作空间这个配置我们暂时不用，<br>name这时候，我们的默认工作空间在哪里呢，如下<br><img src="/07/201809091716-jenkins在windows下的自动集成/jenkins创建任务配置2.png" alt="jenkins创建任务配置2"><br>当然，你使用它也没问题，那你需要在配置-&gt;构建-&gt;批量执行windows命令中，做相应的修改</p><p>7.构建触发器，构建环境暂时我们不配置</p><p>8.在构建中(打包)，点击增加构建步骤-&gt;执行windows批处理命令（1），即会增加一个执行块（2），再出先得执行块里输入相应的命令<br>这里是windows命令<br><img src="/07/201809091716-jenkins在windows下的自动集成/jenkins创建任务配置3.png" alt="jenkins创建任务配置3"></p><p>9.在构建后中(发布)，我们，先点击增加构建后操作步骤，选择-&gt;Deploy war/ear to a container,在出现的配置框填写相应的信息，<br>在增加containers中点击Add Container,选择tomcat版本（博主这里8.x），点击Add,在弹出页中填写2步骤配置的用户名，密码确认即可，然后选择<br><img src="/07/201809091716-jenkins在windows下的自动集成/jenkins创建任务配置4.png" alt="jenkins创建任务配置4"><br><img src="/07/201809091716-jenkins在windows下的自动集成/jenkins创建任务配置5.png" alt="jenkins创建任务配置5"><br>10.点击应用-&gt;保存。至此，配置已经完成，返回创建任务的主页面</p><p>11.点击立即构建，构建历史就会出现构建的进度，构建完成记录前图标蓝色，构建失败红色。可以在页面访问<a href="http://localhost/test,也可以在webapp" target="_blank" rel="noopener">http://localhost/test,也可以在webapp</a><br>中查看项目war是否已经构建并解压</p><h2 id="碰到的问题以及解决方法"><a href="#碰到的问题以及解决方法" class="headerlink" title="碰到的问题以及解决方法"></a>碰到的问题以及解决方法</h2><p>1.需要先启动tomcat，不启动直接在jenkins执行构建任务则会失败。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;jenkins优秀的自动集成解决繁琐的项目部署问题，对于提高开发效率有显著的帮助&lt;/p&gt;
&lt;h1 id=&quot;执行&quot;&gt;&lt;a href=&quot;#执行&quot; class=&quot;headerlink&quot; title=&quot;执行&quot;&gt;&lt;/a&gt;执行&lt;/h1&gt;&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;1.需要自动集成的项目test（博主这里创建了一个简单的maven项目）&lt;/p&gt;
&lt;p&gt;2.tomcat配置&lt;/p&gt;
&lt;h2 id=&quot;大致流程&quot;&gt;&lt;a href=&quot;#大致流程&quot; class=&quot;headerlink&quot; title=&quot;大致流程&quot;&gt;&lt;/a&gt;大致流程&lt;/h2&gt;&lt;p&gt;1.创建或准备一个项目（博主这里名为test的maven项目）&lt;/p&gt;
&lt;p&gt;2.启动的jenkins与安装的插件&lt;/p&gt;
&lt;p&gt;3.tomcat的manager用户配置信息（博主这里admin）&lt;/p&gt;
    
    </summary>
    
      <category term="数据集成" scheme="blog.virualyz.com/categories/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90/"/>
    
    
      <category term="jenkins" scheme="blog.virualyz.com/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>jenkins介绍-安装</title>
    <link href="blog.virualyz.com/2018/09/04/201809042330-jenkins%E4%BB%8B%E7%BB%8D-%E5%AE%89%E8%A3%85/"/>
    <id>blog.virualyz.com/2018/09/04/201809042330-jenkins介绍-安装/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2019-02-24T07:47:44.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><a href="http://mirrors.jenkins-ci.org/war/latest/jenkins.war" target="_blank" rel="noopener">jenkins下载地址</a></p><a id="more"></a> <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>jenkins部署有两种方法</p><p>1.执行命令，访问<a href="http://localhost:8081，然后输入信息即可。" target="_blank" rel="noopener">http://localhost:8081，然后输入信息即可。</a></p><p>2.把下载的文件放入tomcat的webapps下，访问地址<a href="http://localhost:8081/jenkins" target="_blank" rel="noopener">http://localhost:8081/jenkins</a></p><h2 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>这里采用第一种方式</p><p>1.下载<a href="http://mirrors.jenkins-ci.org/war/latest/jenkins.war" target="_blank" rel="noopener">jenkins</a></p><p>2.java -jar C:\Users\time\Downloads\jenkins.war –httpPort=8081<br>或 java -jar C:\Users\time\Downloads\jenkins.war<br><img src="/04/201809042330-jenkins介绍-安装/jenkins执行命令.png" alt="jenkins执行命令"></p><p>3.访问地址<a href="http://localhost:8081(如果采用第二种请访问第二个地址)" target="_blank" rel="noopener">http://localhost:8081(如果采用第二种请访问第二个地址)</a></p><p>4.显示页面，并让你输入密码，密码在页面提示路径文件里这里url为：C:\Users*<strong>**</strong>.jenkins\secrets\initialAdminPassword，<br>在initialAdminPassword文件中招待密码，粘贴复制到浏览器页面，回车<br><img src="/04/201809042330-jenkins介绍-安装/jenkins默认进入输入管理员密码.png" alt="jenkins默认进入输入管理员密码"></p><p>5.输入后会等待启动，然后选择插件形式，这里博主选择左边选项-安装推荐的插件，第一次使用还是选择默认的<br><img src="/04/201809042330-jenkins介绍-安装/jenkins安装插件选择.png" alt="jenkins安装插件选择"></p><p>6.选择后进入插件安装页面，如图，等待完成<br><img src="/04/201809042330-jenkins介绍-安装/jenkins插件安装页面.png" alt="jenkins插件安装页面"></p><p>7.创建管理员账号，这里可以创建也可以不创建，创建则输入账号，密码。不创建则通过admin登录<br><img src="/04/201809042330-jenkins介绍-安装/jenkins创建管理员用户.png" alt="jenkins创建管理员用户"></p><p>8.填写或修改实例配置url，默认<br><img src="/04/201809042330-jenkins介绍-安装/jenkins实例配置.png" alt="jenkins实例配置"></p><p>6.完成安装<br><img src="/04/201809042330-jenkins介绍-安装/jenkins安装成功.png" alt="jenkins安装成功"></p><p>7.进入即可看到如下界面<br><img src="/04/201809042330-jenkins介绍-安装/jenkins管理员登录界面.png" alt="jenkins管理员登录界面"></p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>关闭jenkins服务</p><p>只需要在访问jenkins服务器的网址url地址后加上exit，例如：<a href="http://localhost:8081/exit" target="_blank" rel="noopener">http://localhost:8081/exit</a><br><img src="/04/201809042330-jenkins介绍-安装/jenkins关闭.png" alt="jenkins关闭"></p><p>回车后,点击Retry using POST/使用POST重试，即会关闭<br><img src="/04/201809042330-jenkins介绍-安装/jenkins关闭确认.png" alt="jenkins关闭确认"></p><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>重启jenkins服务（与关闭相似）</p><p>只需要在访问jenkins服务器的网址url地址后加上restart，例如：<a href="http://localhost:8081/restart" target="_blank" rel="noopener">http://localhost:8081/restart</a></p><p>在新出现的界面上点击yes/是，即可</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重新加载jenkins服务配置信息（与关闭相似）</p><p>只需要在访问jenkins服务器的网址url地址后加上reload，例如：<a href="http://localhost:8081/reload" target="_blank" rel="noopener">http://localhost:8081/reload</a></p><h2 id="碰到的问题以及解决方法"><a href="#碰到的问题以及解决方法" class="headerlink" title="碰到的问题以及解决方法"></a>碰到的问题以及解决方法</h2><p>1.安装后，自动启动失败</p><pre><code>信息: Shutting down a Jenkins instance that was still starting upjava.lang.Throwable: reason    at hudson.WebAppMain.contextDestroyed(WebAppMain.java:388)    at org.eclipse.jetty.server.handler.ContextHandler.callContextDestroyed(ContextHandler.java:961)    at org.eclipse.jetty.servlet.ServletContextHandler.callContextDestroyed(ServletContextHandler.java:571)    at org.eclipse.jetty.server.handler.ContextHandler.stopContext(ContextHandler.java:938)    at org.eclipse.jetty.servlet.ServletContextHandler.stopContext(ServletContextHandler.java:381)    at org.eclipse.jetty.webapp.WebAppContext.stopWebapp(WebAppContext.java:1503)    at org.eclipse.jetty.webapp.WebAppContext.stopContext(WebAppContext.java:1467)    at org.eclipse.jetty.server.handler.ContextHandler.doStop(ContextHandler.java:990)    at org.eclipse.jetty.servlet.ServletContextHandler.doStop(ServletContextHandler.java:297)    at org.eclipse.jetty.webapp.WebAppContext.doStop(WebAppContext.java:569)    at org.eclipse.jetty.util.component.AbstractLifeCycle.stop(AbstractLifeCycle.java:89)    at org.eclipse.jetty.util.component.ContainerLifeCycle.stop(ContainerLifeCycle.java:149)    at org.eclipse.jetty.util.component.ContainerLifeCycle.doStop(ContainerLifeCycle.java:170)    at org.eclipse.jetty.server.handler.AbstractHandler.doStop(AbstractHandler.java:124)    at org.eclipse.jetty.server.Server.doStop(Server.java:490)    at org.eclipse.jetty.util.component.AbstractLifeCycle.stop(AbstractLifeCycle.java:89)    at winstone.Launcher.shutdown(Launcher.java:310)    at winstone.Launcher.&lt;init&gt;(Launcher.java:197)    at winstone.Launcher.main(Launcher.java:354)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)    at java.lang.reflect.Method.invoke(Unknown Source)    at Main._main(Main.java:344)    at Main.main(Main.java:160)九月 04, 2018 7:50:11 下午 org.eclipse.jetty.server.handler.ContextHandler doStop信息: Stopped w.@3e0e1046{Jenkins v2.141,/,null,UNAVAILABLE}{C:\Users\T440\.jenkins\war}Exception in thread &quot;Jenkins initialization thread&quot; java.lang.NoClassDefFoundError: hudson/util/HudsonFailedToLoad        at hudson.WebAppMain$3.run(WebAppMain.java:247)Caused by: java.lang.ClassNotFoundException: hudson.util.HudsonFailedToLoad    at java.net.URLClassLoader.findClass(Unknown Source)    at java.lang.ClassLoader.loadClass(Unknown Source)    at java.lang.ClassLoader.loadClass(Unknown Source)    at org.eclipse.jetty.webapp.WebAppClassLoader.loadClass(WebAppClassLoader.java:565)    at java.lang.ClassLoader.loadClass(Unknown Source)    ... 1 more九月 04, 2018 7:50:11 下午 winstone.Logger logInternal信息: Jetty shutdown successfullyjava.io.IOException: Failed to start Jetty    at winstone.Launcher.&lt;init&gt;(Launcher.java:186)    at winstone.Launcher.main(Launcher.java:354)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)    at java.lang.reflect.Method.invoke(Unknown Source)    at Main._main(Main.java:344)    at Main.main(Main.java:160)Caused by: java.net.BindException: Address already in use: bind    at sun.nio.ch.Net.bind0(Native Method)    at sun.nio.ch.Net.bind(Unknown Source)    at sun.nio.ch.Net.bind(Unknown Source)    at sun.nio.ch.ServerSocketChannelImpl.bind(Unknown Source)    at sun.nio.ch.ServerSocketAdaptor.bind(Unknown Source)    at org.eclipse.jetty.server.ServerConnector.openAcceptChannel(ServerConnector.java:331)    at org.eclipse.jetty.server.ServerConnector.open(ServerConnector.java:299)    at org.eclipse.jetty.server.AbstractNetworkConnector.doStart(AbstractNetworkConnector.java:80)    at org.eclipse.jetty.server.ServerConnector.doStart(ServerConnector.java:235)    at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)    at org.eclipse.jetty.server.Server.doStart(Server.java:398)    at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)    at winstone.Launcher.&lt;init&gt;(Launcher.java:184)    ... 7 more[31m九月 04, 2018 7:50:11 下午 winstone.Logger logInternal严重: Container startup failedjava.io.IOException: Failed to start Jetty    at winstone.Launcher.&lt;init&gt;(Launcher.java:186)    at winstone.Launcher.main(Launcher.java:354)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)    at java.lang.reflect.Method.invoke(Unknown Source)    at Main._main(Main.java:344)    at Main.main(Main.java:160)Caused by: java.net.BindException: Address already in use: bind    at sun.nio.ch.Net.bind0(Native Method)    at sun.nio.ch.Net.bind(Unknown Source)    at sun.nio.ch.Net.bind(Unknown Source)    at sun.nio.ch.ServerSocketChannelImpl.bind(Unknown Source)    at sun.nio.ch.ServerSocketAdaptor.bind(Unknown Source)    at org.eclipse.jetty.server.ServerConnector.openAcceptChannel(ServerConnector.java:331)    at org.eclipse.jetty.server.ServerConnector.open(ServerConnector.java:299)    at org.eclipse.jetty.server.AbstractNetworkConnector.doStart(AbstractNetworkConnector.java:80)    at org.eclipse.jetty.server.ServerConnector.doStart(ServerConnector.java:235)    at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)    at org.eclipse.jetty.server.Server.doStart(Server.java:398)    at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68)    at winstone.Launcher.&lt;init&gt;(Launcher.java:184)    ... 7 more</code></pre><p>怀疑是端口问题，百度了下，确实是端口冲突，之前启动了一个项目，占用了8080端口，jenkins默认8080端口，这个时候可以 在启动war包时候增加端口，命令为 </p><pre><code>java -jar jenkinsWAR包路径  --httpPort=$HTTP_PORT</code></pre><p>exp</p><pre><code>java -jar D:\jenkins.war --httpPort=8081    </code></pre><p>然后等在启动访问 </p><pre><code>http://localhost:8081/</code></pre><p>就会看到jenkins界面了</p><p>2.在安装中创建管理员账号时需要填写邮箱，不填写无法保存，也不报错</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/bingoxubin/article/details/78720976" target="_blank" rel="noopener">https://blog.csdn.net/bingoxubin/article/details/78720976</a></p><p><a href="https://blog.csdn.net/bingoxubin/article/details/78720976" target="_blank" rel="noopener">https://blog.csdn.net/bingoxubin/article/details/78720976</a></p><p><a href="https://blog.csdn.net/itfootball/article/details/44876517" target="_blank" rel="noopener">关闭重启jenkins</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://mirrors.jenkins-ci.org/war/latest/jenkins.war&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jenkins下载地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据集成" scheme="blog.virualyz.com/categories/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90/"/>
    
    
      <category term="jenkins" scheme="blog.virualyz.com/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>初步了解数据库</title>
    <link href="blog.virualyz.com/2018/09/03/201809030244-%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>blog.virualyz.com/2018/09/03/201809030244-初步了解数据库/</id>
    <published>2018-09-02T18:45:30.000Z</published>
    <updated>2019-02-24T07:47:44.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h5 id="数据库定义"><a href="#数据库定义" class="headerlink" title="数据库定义"></a>数据库定义</h5><p>数据库(Database)是按照数据结构来组织、存储和管理数据的仓库</p><h5 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h5><p>早起数据库比较流行的数据库类型分为三类：层次式数据库、网络式数据库和关系型数据库(现在大部分为关系型数据库)。而当今互联网常见的数据库类型分为两类：关系型、非关系型。</p><h6 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h6><p>关系型数据库模型是把复杂的数据结构归为简单的二元关系(即二维表格形式)，在关系型数据库中，对数据的操作就全部建立在一个或多个表格中，通过这些表格的分类、合并、连接或选取等运算来实现数据的管理。</p><p>关系型数据库诞生于1969年，由 Edgar F.“Ted” Codd发明了关系数据库。最常见的关系型数据库：mysql、Oracle、DB2、MariaDB(mysql分支）、Microsoft SQL Server(微软)，Access（Microsoft）</p><h6 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h6><p>非关系型数据库又被称为NoSQL（以下简称NoSQL），NoSQL不是没有SQL的意思，而是“不仅仅是SQL”（not only sql），NoSQL的产生并不是要彻底否定关系型数据库，而是作为传统关系型数据库的一个有效补充。NOSQL典型产品memcached（纯内存），redis（持久化缓存），mongodb（面向文档）</p><a id="more"></a> <p>####### NoSQL的四大分类</p><p>1.键值存储数据库 </p><pre><code>典型产品：Memcached、Redis、MemcacheDB、Berkeley DB</code></pre><p>2.列存储数据库</p><pre><code>典型产品：Hbase、Cassandra</code></pre><p>3.文档型数据库</p><pre><code>典型产品：MongoDB、CouchDB</code></pre><p>4.图形（Graph）数据库</p><pre><code>典型的产品有：Neo4J、InfoGrid。</code></pre><p>####### NoSQL共同特征</p><p>1.不需要预定义模式:在存储时不需要预先定义他们的模式</p><p>2.无共享架构:NoSQL把数据存储在本地服务器上，从本地磁盘读取数据比通过网络获取数据快，从而提高了性能</p><p>3.弹性可扩展</p><p>4.分区</p><p>5.异步复制</p><p>6.BASE:关系型数据库是严格的ACID特性，NoSQL数据库保证的是BASE特性。BASE是最终一致性和软事务</p><p>NoSQL数据库并没有一个统一的架构，两种NoSQL数据库之间的不同，甚至远远超过两种关系型数据库的不同。可以说，NoSQL各有所长，成功的NoSQL必然特别适用于某些场合或者某些应用，在这些场合中会远远胜过关系型数据库和其他的NoSQL。</p><p>####### NoSQL 适用场景</p><p>1.数据模型比较简单；</p><p>2.需要灵活性更强的IT系统；</p><p>3.对数据库性能要求较高；</p><p>4.不需要高度的数据一致性；</p><p>5.对于给定key，比较容易映射复杂值的环境。</p><h5 id="数据库排名"><a href="#数据库排名" class="headerlink" title="数据库排名"></a>数据库排名</h5><p>地址：<a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">https://db-engines.com/en/ranking</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://baike.baidu.com/item/NoSQL/8828247?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/NoSQL/8828247?fr=aladdin</a><br><a href="http://blog.51cto.com/13178102/2064041" target="_blank" rel="noopener">http://blog.51cto.com/13178102/2064041</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;h5 id=&quot;数据库定义&quot;&gt;&lt;a href=&quot;#数据库定义&quot; class=&quot;headerlink&quot; title=&quot;数据库定义&quot;&gt;&lt;/a&gt;数据库定义&lt;/h5&gt;&lt;p&gt;数据库(Database)是按照数据结构来组织、存储和管理数据的仓库&lt;/p&gt;
&lt;h5 id=&quot;数据库分类&quot;&gt;&lt;a href=&quot;#数据库分类&quot; class=&quot;headerlink&quot; title=&quot;数据库分类&quot;&gt;&lt;/a&gt;数据库分类&lt;/h5&gt;&lt;p&gt;早起数据库比较流行的数据库类型分为三类：层次式数据库、网络式数据库和关系型数据库(现在大部分为关系型数据库)。而当今互联网常见的数据库类型分为两类：关系型、非关系型。&lt;/p&gt;
&lt;h6 id=&quot;关系型数据库&quot;&gt;&lt;a href=&quot;#关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库&quot;&gt;&lt;/a&gt;关系型数据库&lt;/h6&gt;&lt;p&gt;关系型数据库模型是把复杂的数据结构归为简单的二元关系(即二维表格形式)，在关系型数据库中，对数据的操作就全部建立在一个或多个表格中，通过这些表格的分类、合并、连接或选取等运算来实现数据的管理。&lt;/p&gt;
&lt;p&gt;关系型数据库诞生于1969年，由 Edgar F.“Ted” Codd发明了关系数据库。最常见的关系型数据库：mysql、Oracle、DB2、MariaDB(mysql分支）、Microsoft SQL Server(微软)，Access（Microsoft）&lt;/p&gt;
&lt;h6 id=&quot;非关系型数据库&quot;&gt;&lt;a href=&quot;#非关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;非关系型数据库&quot;&gt;&lt;/a&gt;非关系型数据库&lt;/h6&gt;&lt;p&gt;非关系型数据库又被称为NoSQL（以下简称NoSQL），NoSQL不是没有SQL的意思，而是“不仅仅是SQL”（not only sql），NoSQL的产生并不是要彻底否定关系型数据库，而是作为传统关系型数据库的一个有效补充。NOSQL典型产品memcached（纯内存），redis（持久化缓存），mongodb（面向文档）&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="blog.virualyz.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="blog.virualyz.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>设计模式介绍</title>
    <link href="blog.virualyz.com/2018/08/31/201808310312-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
    <id>blog.virualyz.com/2018/08/31/201808310312-设计模式介绍/</id>
    <published>2018-08-30T16:00:00.000Z</published>
    <updated>2019-04-05T13:02:00.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。<br>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性</p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）<br>，一共有23种设计模式。</p><p>这些模式可以分为三大类：</p><ul><li>创建模式(五)：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式</li><li>结构模式(七)：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式</li><li>行为模式(十一)：策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式</li></ul><a id="more"></a> <h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p>总原则：开闭原则</p><ul><li>单一职责原则</li><li>里氏替换原则</li><li>依赖倒转原则</li><li>接口隔离原则</li><li>最少知道原则(迪米特法则)</li><li>合成复用原则</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/geek6/p/3951677.html" target="_blank" rel="noopener">https://www.cnblogs.com/geek6/p/3951677.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。&lt;br&gt;使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性&lt;/p&gt;
&lt;h2 id=&quot;设计模式分类&quot;&gt;&lt;a href=&quot;#设计模式分类&quot; class=&quot;headerlink&quot; title=&quot;设计模式分类&quot;&gt;&lt;/a&gt;设计模式分类&lt;/h2&gt;&lt;p&gt;根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）&lt;br&gt;，一共有23种设计模式。&lt;/p&gt;
&lt;p&gt;这些模式可以分为三大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建模式(五)：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式&lt;/li&gt;
&lt;li&gt;结构模式(七)：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式&lt;/li&gt;
&lt;li&gt;行为模式(十一)：策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="blog.virualyz.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="blog.virualyz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
